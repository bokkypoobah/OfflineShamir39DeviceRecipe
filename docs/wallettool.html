<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WalletTool:TopSecrets</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="WalletTool:TopSecrets (c) Bok Consulting Pty Ltd 2024" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="globals.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/ApprovalTool/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/topsecrets.svg" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">WalletTool:TopSecrets</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Explore Mnemonic and Private Key Wallets'">Wallet Tool</b-nav-item> -->
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert size="sm" dismissible variant="warning" show class="m-1 mb-0 my-0">
            Warning: This is experimental unaudited work-in-progress software. This dapp is meant for use on permanently offline computers.
          </b-alert>
          <b-card v-if="false" class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Mainnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <!-- :MODALLOADPRIVATEKEYFROMKEYSTORE -->
          <b-modal id="modal-loadprivatekeyfromkeystore" hide-footer size="lg">
            <template #modal-title>
              Load Private Key From JSON/UTC Keystore
            </template>
            <b-form-group label="Keystore File:" label-for="modal-loadprivatekeyfromkeystore-keystorefile" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Select encrypted keystore (JSON/UTC) file from your local computer'" class="mx-0 my-1 p-0">
              <b-form-file size="sm" id="modal-loadprivatekeyfromkeystore-keystorefile" v-model="wallet.keystoreFile" @change="keystoreFileChange($event.target.name, $event.target.files)"></b-form-file>
            </b-form-group>
            <b-form-group label="Password:" label-for="modal-loadprivatekeyfromkeystore-keystorefilepassword" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="password" autocomplete="current-password" size="sm" id="modal-loadprivatekeyfromkeystore-keystorefilepassword" v-model.trim="wallet.keystoreFilePassword" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="modal-loadprivatekeyfromkeystore-load" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="modal-loadprivatekeyfromkeystore-load" @click="loadPrivateKeyFromKeystore()" variant="primary">Load</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALSAVEPRIVATEKEYTOKEYSTORE -->
          <b-modal id="modal-saveprivatekeytokeystore" hide-footer size="md">
            <template #modal-title>
              Save Private Key To JSON/UTC Keystore
            </template>
            <b-form-group label="Keystore File Password:" label-for="modal-saveprivatekeytokeystore-password" label-size="sm" label-cols-sm="5" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="password" autocomplete="current-password" size="sm" id="modal-saveprivatekeytokeystore-password" v-model="wallet.keystoreFilePassword"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="modal-saveprivatekeytokeystore-save" label-size="sm" label-cols-sm="5" label-align-sm="right" description="The encryption process may take up to half a minute" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!wallet.keystoreFilePassword" id="modal-saveprivatekeytokeystore-save" @click="savePrivateKeyToKeystore()" variant="primary">Save</b-button>
            </b-form-group>
          </b-modal>

          <!-- :WALLETTOOL -->
          <b-card v-if="settings.tabIndex == 5" sub-title="Wallet Tool" bg-variant="light" class="p-0 m-1">
            <b-card bg-variant="light" no-body class="p-0 m-1">
              <b-tabs card align="left" no-body v-model="wallet.tab" active-tab-class="m-0 p-0">
                <b-tab v-for="t in tabs" :key="'dyn-tabx-' + t.name" @click="updateURL(t.name);" :title="t.text" title-item-class="p-0" title-link-class="mt-2 px-3">
                </b-tab>
              </b-tabs>
              <b-card-text class="m-0 p-2">
                <b-form-group v-if="wallet.tab == 0" label="Phrase:" label-for="wallet-mnemonicphrase" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                  <b-form-textarea size="sm" id="wallet-mnemonicphrase" v-model="wallet.mnemonic.phrase" @change="generateDerivedAddresses();" rows="3" placeholder="Type/paste your mnemnonic seed phrase here or click [Generate New]" style="max-width: 800px;"></b-form-textarea>
                </b-form-group>
                <b-form-group v-if="wallet.tab == 0" label="" label-for="wallet-generaterandom" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-input-group style="max-width: 300px;">
                    <b-form-select size="sm" v-model="wallet.randomBytesLength" :options="randomBytesLengthMnemonicWordsOptions"></b-form-select>
                    <b-input-group-append>
                      <b-button size="sm" id="wallet-generaterandom" @click="generateRandomMnemonic()" variant="primary">Generate Random</b-button>
                    </b-input-group-append>
                  </b-input-group>
                </b-form-group>
                <b-form-group v-if="wallet.tab == 0" label="Passphrase:" label-for="wallet-mnemonicpassphrase" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                  <b-form-input type="text" size="sm" id="wallet-mnemonicpassphrase" v-model="wallet.mnemonic.passphrase" @change="generateDerivedAddresses();" placeholder="Optional" style="max-width: 300px;"></b-form-input>
                </b-form-group>
                <b-card v-if="wallet.tab == 0" class="m-0 mt-2 p-0 border-0" body-class="m-1 p-0">
                  <div class="d-flex flex-wrap m-0 p-0">
                    <div class="mt-1 pl-1">
                      <font size="-1">Derivation Path:</font>
                    </div>
                    <div class="mt-0 pl-1">
                      <b-form-select size="sm" v-model="wallet.derivationPath" :options="derivationPathOptions" @change="generateDerivedAddresses();" style="max-width: 300px;" v-b-popover.hover.bottom="'Derivation Path'"></b-form-select>
                    </div>
                    <div class="mt-0 flex-grow-1">
                    </div>
                    <div class="mt-1 pr-1">
                      <font size="-1">Start:</font>
                    </div>
                    <div class="mt-0 pr-1">
                      <b-form-spinbutton size="sm" v-model="wallet.page" min="0" @change="generateDerivedAddresses();" inline v-b-popover.hover.bottom="'Page'"></b-form-spinbutton>
                    </div>
                    <div class="mt-0">
                      <b-form-select size="sm" v-model="wallet.pageSize" :options="indexPageSizeOptions" @change="generateDerivedAddresses();"></b-form-select>
                    </div>
                  </div>
                  <b-table ref="addressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='generatedAddressesRowSelected':fields="generatedAddressesFields" :items="generatedAddresses" show-empty empty-html="Enter information above" head-variant="light" class="mx-0 my-1">
                    <template #cell(index)="data">
                      <font size="-1">
                        {{ data.item.index }}
                      </font>
                    </template>
                    <template #cell(path)="data">
                      <!-- <font size="-1"> -->
                        {{ data.item.path }}
                      <!-- </font> -->
                    </template>
                    <template #cell(address)="data">
                      <!-- <font size="-1"> -->
                        {{ data.item.address }}
                      <!-- </font> -->
                    </template>
                    <template #cell(privateKey)="data">
                      <!-- <font size="-1"> -->
                        {{ data.item.privateKey }}
                      <!-- </font> -->
                    </template>
                  </b-table>
                </b-card>
                <b-form-group v-if="wallet.tab == 1" label="Private Key:" label-for="wallet-privatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.privateKeyError" :invalid-feedback="wallet.privateKeyError" class="mx-0 my-2 p-0">
                  <b-form-input type="text" size="sm" id="wallet-privatekey" v-model="wallet.privateKey" @change="recomputeFromPrivateKey();" placeholder="Type/paste your private key here, click [Generate New] or [Load From Keystore]" class="w-75"></b-form-input>
                </b-form-group>
                <b-form-group v-if="wallet.tab == 1" label="" label-for="wallet-generaterandomprivatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-button size="sm" id="wallet-generaterandomprivatekey" @click="generateRandomPrivateKey()" variant="primary">Generate New</b-button>
                  <b-button size="sm" @click="showLoadPrivateKeyFromKeystoreModal()" variant="primary">Load From Keystore</b-button>
                  <b-button size="sm" :disabled="!wallet.privateKey || !!wallet.privateKeyError" @click="showSavePrivateKeyToKeystoreModal()" variant="primary">Save To Keystore</b-button>
                </b-form-group>
                <b-form-group v-if="wallet.tab == 1" label="ETH Address:" label-for="output-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-3 p-0">
                  <b-form-input type="text" size="sm" readonly id="output-address" :value="wallet.address" class="w-50"></b-form-input>
                </b-form-group>
                <b-form-group v-if="false && wallet.tab == 0" label="Debug Addresses:" label-for="debug-addresses-textarea" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 mt-3 p-0">
                  <b-form-textarea size="sm" readonly id="debug-addresses-textarea" :value="JSON.stringify(generatedAddresses, null, 2)" rows="3" max-rows="10" class="w-100"></b-form-textarea>
                </b-form-group>
                <b-form-group v-if="false" label="Debug:" label-for="debug-textarea" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 mt-3 p-0">
                  <b-form-textarea size="sm" readonly id="debug-textarea" :value="JSON.stringify(wallet, null, 2)" rows="3" max-rows="10" class="w-100"></b-form-textarea>
                </b-form-group>
                <b-form-group v-if="false" label="Test:" label-for="wallet-testit" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-button size="sm" id="wallet-testit" @click="testIt()" variant="warning">Test</b-button>
                </b-form-group>
              </b-card-text>
            </b-card>
          </b-card>
        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="false && connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>WalletTool:TopSecrets</i> &copy; Bok Consulting Pty Ltd 2024
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          wallet: {
            tab: 0, // 0: 'mnemonic', 1: 'privatekey'

            type: 'mnemonic', // 'mnemonic', 'privatekey'
            wallet: null, // HDNode for type 'mnemonic', Wallet for type 'privatekey'

            mnemonic: {
              phrase: null,
              phraseError: null,
              passphrase: null,
              path: "m/44'/60'/0'/0/0", // null,
              locale: null,
            },

            derivationPath: "m/44'/60'/0'/0/{index}",
            page: 0,
            pageSize: 10,

            keystoreFile: null,
            keystoreFilePassword: null,
            keystoreFileContent: null,

            privateKey: null,
            privateKeyError: null,

            randomBytesLength: 16, // 12 words

            publicKey: null,
            compressedPublicKey: null,
            address: null,

            hiddenUsername: null, // For HTML accessibility
          },

          newWalletFromMnemonic: {
            phrase: null,
            randomBytesLength: 16, // 12 words
            phraseError: null,
            passphrase: null,
            derivationPath: "m/44'/60'/0'/0/{index}",
            page: 0,
            pageSize: 10,
            selectedItem: null,
            name: null,
            // path: "m/44'/60'/0'/0/0", // null,
            // locale: null,
            password: null,
            confirmPassword: null,
          },

          newWalletFromPrivateKey: {
            privateKey: null,
            privateKeyError: null,
            address: null,
            name: null,
            password: null,
            confirmPassword: null,
          },

          newWalletFromKeystore: {
            keystoreFile: null,
            keystoreFilePassword: null,
            keystoreFileContent: null,
            privateKey: null,
            address: null,
            name: null,
            password: null,
            confirmPassword: null,
          },

          address: {
            mode: 'vieworupdate', // TODO: 'add' or 'vieworupdate'
            type: null,
            address: null,
            addressError: null,
            name: null,
            keystore: null,
            password: null,
            passwordError: null,
            privateKey: null,
          },

          signMessage: {
            wallet: null,
            message: null,
            signature: null,
          },

          checkMessage: {
            message: null,
            signature: null,
          },

          signEthTx: {
            from: null,
            to: null,
            amount: null,
            amountUnit: "ethers",
            data: null,
            nonce: null,
            signature: null,
          },

          generatedAddresses: [],
          selectedAddress: null,

          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,
          forceRefresh: 0,

          settings: {
            tabIndex: 5,
            addressesTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'addressasc',
            },
            version: 12,
          },
          addresses: {},
          // sync: {
          //   section: null,
          //   total: null,
          //   completed: null,
          //   halt: false,
          // },

          tabs: [
            { name: 'mnemonic', text: 'Mnemonic Seed Phrase' },
            { name: 'privatekey', text: 'Private Key' },
          ],

          addressTypeOptions: [
            { value: 'walletfrommnemonic', text: 'Wallet From Mnemonic', disabled: true },
            { value: 'walletfromprivatekey', text: 'Wallet From Private Key', disabled: true },
            { value: 'walletfromkeystore', text: 'Wallet From Keystore', disabled: true },
            { value: 'address', text: 'Address' },
            { value: 'erc20', text: 'ERC-20 Token Contract' },
            { value: 'erc721', text: 'ERC-721 Token Contract' },
            { value: 'contract', text: 'Contract' },
          ],

          randomBytesLengthMnemonicWordsOptions: [
            { value: 16, text: '12 Words' },
            { value: 20, text: '15 Words' },
            { value: 24, text: '18 Words' },
            { value: 28, text: '21 Words' },
            { value: 32, text: '24 Words' },
          ],

          unitOptions: [
            { value: "ethers", text: 'Ethers' },
            { value: "gwei", text: 'Gwei' },
            { value: "wei", text: 'Wei' },
          ],

          // MM HW Paths
          // Ledger Live
          // Legacy (MEW/MyCrypto)
          // BIP44 Standard (e.g. MetaMask, Trezor)
          derivationPathOptions: [
            { value: "m/44'/60'/0'/0/{index}", text: "BIP-44 m/44'/60'/0'/0/{index}" },
            { value: "m/44'/60'/0'/0/{index}", text: "Legacy (MEW/MyCrypto) m/44'/60'/0'/0/{index}" }, // TODO: Check difference in MM settings with Ledger
            { value: "m/44'/60'/0'/{index}/0", text: "Test-1 m/44'/60'/0'/{index}/0" },
            { value: "m/44'/60'/0'/0/{index}/0", text: "Test-2 m/44'/60'/0'/0/{index}/0" },
          ],

          indexPageSizeOptions: [
            { value: 1, text: '1' },
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
          ],

          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],

          newWalletFromMnemonicAddressesFields: [
            { key: 'index', label: '#', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'path', label: 'Path', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 60%;', thClass: 'text-left', tdClass: 'text-left' },
            // { key: 'privateKey', label: 'Private Key', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
          ],

          generatedAddressesFields: [
            { key: 'index', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'path', label: 'Path', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 35%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'privateKey', label: 'Private Key', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-left' },
          ],

          addressesFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-truncate' },
          ],

        },

        // --- COMPUTED ---
        computed: {

          addressesOptions() {
            const results = [];
            results.push({ value: null, text: "(Select)" });
            for (const [address, data] of Object.entries(this.addresses)) {
              results.push({ value: address, text: address + (data.name ? (" " + data.name) : "") });
            }
            return results;
          },

          checkMessageRecoveredAddress() {
            let result = null;
            if (this.checkMessage.message && this.checkMessage.signature) {
              try {
                console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress - message: " + this.checkMessage.message);
                let pubKey = ethers.utils.recoverPublicKey(ethers.utils.arrayify(ethers.utils.hashMessage(this.checkMessage.message)), this.checkMessage.signature);
                result = ethers.utils.computeAddress(pubKey);
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress ERROR: " + e.message);
              }
            }
            return result;
          },

          newWalletFromMnemonicAddresses() {
            const results = [];
            if (this.newWalletFromMnemonic.phrase) {
              try {
                const node = ethers.utils.HDNode.fromMnemonic(this.newWalletFromMnemonic.phrase, this.newWalletFromMnemonic.passphrase);
                for (let i = 0; i < this.newWalletFromMnemonic.pageSize; i++) {
                  const index = parseInt(i) + (this.newWalletFromMnemonic.page * this.newWalletFromMnemonic.pageSize);
                  let path = this.newWalletFromMnemonic.derivationPath.replace(/{index}/, index);
                  console.log("index: " + index + " => " + path);
                  const w = node.derivePath(path);
                  results.push({
                    index,
                    path,
                    privateKey: w.privateKey,
                    address: w.address,
                    // publicKey: w.publicKey,
                    // compressedPublicKey: ethers.utils.computePublicKey(w.publicKey, true),
                  });
                }
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAddresses ERROR: " + e.message);
              }
            }
            return results;
          },

          filteredAddresses() {
            // console.log(moment().format("HH:mm:ss") + " filteredAddresses: " + JSON.stringify(this.addresses));
            // let results = this.forceRefresh % 2 == 0 ? [] : [];
            const results = [];
            for (const [address, data] of Object.entries(this.addresses)) {
              results.push({
                address,
                type: data.type,
                keystore: data.keystore,
                name: data.name,
              });
            }
            return results;
          },
          filteredSortedAddresses() {
            let results = this.filteredAddresses;
          //   if (this.settings.accountsTable.sortOption == 'typenameasc') {
          //     results.sort((a, b) => {
          //       const typeA = a.customType || a.type;
          //       const typeB = b.customType || b.type;
          //       const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
          //       const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
          //       if (sortIndexA == sortIndexB) {
          //         const namea = a.customName || a.name;
          //         const nameb = b.customName || b.name;
          //         return ('' + namea).localeCompare(nameb);
          //       } else {
          //         return sortIndexA - sortIndexB;
          //       }
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'typenamedsc') {
          //     results.sort((a, b) => {
          //       const typeA = a.customType || a.type;
          //       const typeB = b.customType || b.type;
          //       const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
          //       const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
          //       if (sortIndexA == sortIndexB) {
          //         const namea = a.customName || a.name;
          //         const nameb = b.customName || b.name;
          //         return ('' + nameb).localeCompare(namea);
          //       } else {
          //         return sortIndexB - sortIndexA;
          //       }
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'nameasc') {
          //     results.sort((a, b) => {
          //       return ('' + a.name).localeCompare(b.name);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'namedsc') {
          //     results.sort((a, b) => {
          //       return ('' + b.name).localeCompare(a.name);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'addressasc') {
          //     results.sort((a, b) => {
          //       return ('' + a.address).localeCompare(b.address);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'addressdsc') {
          //     results.sort((a, b) => {
          //       return ('' + b.address).localeCompare(a.address);
          //     });
          //   }
            return results;
          },
          pagedFilteredSortedWallets() {
            console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedWallets - results[0..1]: " + JSON.stringify(this.filteredSortedAddresses.slice(0, 2), null, 2));
            return this.filteredSortedAddresses.slice((this.settings.addressesTable.currentPage - 1) * this.settings.addressesTable.pageSize, this.settings.addressesTable.currentPage * this.settings.addressesTable.pageSize);
          },

          accountsToSearch() {
            return this.settings.searchAttachedAccount ? [ this.coinbase ] : (this.settings.searchAccounts && this.settings.searchAccounts.split(/[, \t\n]+/).filter(name => name.match(/0x[0-9a-fA-F]{40}/)) || []);
          },
        },

        // --- METHODS ---
        methods: {

          updateURL(where) {
            console.log(moment().format("HH:mm:ss") + " TODO updateURL: " + where);
          },

          addressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " addressesRowSelected: " + JSON.stringify(item));
            if (item && item.length > 0) {
              this.address.mode = 'vieworupdate';
              this.address.type = item[0].type;
              this.address.address = item[0].address;
              this.address.addressError = null;
              this.address.name = item[0].name;
              this.address.keystore = item[0].keystore;
              this.address.password = null;
              this.address.privateKey = null;
              console.log(moment().format("HH:mm:ss") + " addressesRowSelected - this.address: " + JSON.stringify(this.address));
              this.$refs.addressesTable.clearSelected();
            }
            this.$bvModal.show('modal-address');
          },

          generatedAddressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " generatedAddressesRowSelected: " + JSON.stringify(item));
            if (item && item.length > 0) {
              this.selectedAddress = item[0];
            } else {
              this.selectedAddress = null;
            }
          },

          showLoadPrivateKeyFromKeystoreModal() {
            console.log(moment().format("HH:mm:ss") + " showLoadPrivateKeyFromKeystoreModal");
            this.$bvModal.show('modal-loadprivatekeyfromkeystore');
          },
          showSavePrivateKeyToKeystoreModal() {
            console.log(moment().format("HH:mm:ss") + " showSavePrivateKeyToKeystoreModal");
            this.$bvModal.show('modal-saveprivatekeytokeystore');
          },

          // Older stuff below

          generateDerivedAddresses() {
            console.log(moment().format("HH:mm:ss") + " generateDerivedAddresses - this.wallet: " + JSON.stringify(this.wallet, null, 2));
            const results = [];
            if (this.wallet.type == 'mnemonic' && this.wallet.mnemonic.phrase) {
              try {
                const node = ethers.utils.HDNode.fromMnemonic(this.wallet.mnemonic.phrase, this.wallet.mnemonic.passphrase);
                // for (let index = this.wallet.page; index < (parseInt(this.wallet.page) + this.wallet.pageSize); index++) {
                for (let i = 0; i < this.wallet.pageSize; i++) {
                  const index = parseInt(i) + (this.wallet.page * this.wallet.pageSize);
                  console.log("index: " + index);
                  let path = this.wallet.derivationPath.replace(/{index}/, index);
                  const w = node.derivePath(path);
                  results.push({
                    index,
                    path,
                    privateKey: w.privateKey,
                    address: w.address,
                    publicKey: w.publicKey,
                    compressedPublicKey: ethers.utils.computePublicKey(w.publicKey, true),
                  });
                }
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " generateDerivedAddresses ERROR: " + e.message);
                this.wallet.mnemonic.phraseError = e.message;
              }
            }
            Vue.set(this, 'generatedAddresses', results);
            // console.log(moment().format("HH:mm:ss") + " generateDerivedAddresses - this.generatedAddresses: " + JSON.stringify(this.generatedAddresses, null, 2));
          },

          generateRandomMnemonic() {
            console.log(moment().format("HH:mm:ss") + " generateRandomMnemonic - this.wallet.randomBytesLength: " + this.wallet.randomBytesLength);
            try {
              const randomBytes = ethers.utils.randomBytes(this.wallet.randomBytesLength);
              this.wallet.mnemonic.phrase = ethers.utils.entropyToMnemonic(randomBytes);
              this.wallet.mnemonic.phraseError = null;
              this.generateDerivedAddresses();
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " generateRandomMnemonic ERROR: " + e.message);
              this.wallet.mnemonic.phrase = null;
              this.wallet.mnemonic.phraseError = e.message;
              this.generatedAddresses = [];
            }
            this.$bvModal.hide('modal-generatemnemonic');
          },

          // async recomputeFromMnemonic() {
          //   console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic: " + JSON.stringify(this.wallet));
          //   if (this.wallet.tab == 0) {
          //     console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic - mnemonics: " + JSON.stringify(this.wallet));
          //     try {
          //       const wallet = new ethers.Wallet.fromMnemonic(this.wallet.mnemonic.phrase);
          //       this.wallet.mnemonic.phraseError = null;
          //       this.wallet.address = wallet.address;
          //       this.wallet.publicKey = wallet.publicKey;
          //       this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
          //     } catch (e) {
          //       console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic - mnemonics ERROR: " + e.message);
          //       this.wallet.mnemonic.phraseError = e.message;
          //       this.wallet.address = null;
          //       this.wallet.publicKey = null;
          //       this.wallet.compressedPublicKey = null;
          //     }
          //   }
          // },

          generateRandomPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey");
            try {
              const randomBytes = ethers.utils.randomBytes(16);
              // this.wallet.mnemonic.phrase = ethers.utils.entropyToMnemonic(randomBytes);
              // const node = ethers.utils.HDNode.fromMnemonic(this.wallet.mnemonic.phrase);
              const phrase = ethers.utils.entropyToMnemonic(randomBytes);
              const node = ethers.utils.HDNode.fromMnemonic(phrase);
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey - node: " + JSON.stringify(node, null, 2));
              const defaultPath = "m/44'/60'/0'/0/0";
              const wallet = node.derivePath(defaultPath);
              this.wallet.type = 'keystore';
              this.wallet.wallet = wallet;
              this.wallet.privateKey = wallet.privateKey;
              this.wallet.privateKeyError = null;
              this.wallet.address = wallet.address;
              this.wallet.publicKey = wallet.publicKey;
              this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey - this.wallet: " + JSON.stringify(this.wallet, null, 2));
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey ERROR: " + e.message);
            }
          },

          async recomputeFromPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey: " + JSON.stringify(this.wallet));
            if (this.wallet.tab == 1) {
              console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey - privatekey: " + JSON.stringify(this.wallet));
              if (this.wallet.privateKey) {
                try {
                  const wallet = new ethers.Wallet(this.wallet.privateKey);
                  this.wallet.privateKeyError = null;
                  this.wallet.address = wallet.address;
                  this.wallet.publicKey = wallet.publicKey;
                  this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
                } catch (e) {
                  console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey - privatekey ERROR: " + e.message);
                  this.wallet.privateKeyError = e.message;
                  this.wallet.address = null;
                  this.wallet.publicKey = null;
                  this.wallet.compressedPublicKey = null;
                }
              } else {
                this.wallet.privateKeyError = null;
                this.wallet.address = null;
                this.wallet.publicKey = null;
                this.wallet.compressedPublicKey = null;
              }
            }
          },

          async loadPrivateKeyFromKeystore() {
            console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore");
            try {
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - this.wallet.keystoreFileContent: " + this.wallet.keystoreFileContent);
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - this.wallet.keystoreFilePassword: " + this.wallet.keystoreFilePassword);
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(this.wallet.keystoreFileContent, this.wallet.keystoreFilePassword);
              this.wallet.type = 'keystore';
              this.wallet.wallet = wallet;
              this.wallet.privateKey = wallet.privateKey;
              this.wallet.privateKeyError = null;
              this.wallet.address = wallet.address;
              this.wallet.publicKey = wallet.publicKey;
              this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - keystorefile ERROR: " + e.message);
            }
            this.$bvModal.hide('modal-loadprivatekeyfromkeystore');
          },

          async savePrivateKeyToKeystore() {
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - this.wallet.privateKey: " + JSON.stringify(this.wallet.privateKey));
            const filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.wallet.address.slice(2).toLowerCase();
            console.log("filename: " + filename);
            const wallet = new ethers.Wallet(this.wallet.privateKey);
            const encrypted = await wallet.encrypt(this.wallet.keystoreFilePassword);
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - encrypted: " + encrypted);
            const encryptedObject = JSON.parse(encrypted);
            // const filename = encryptedObject && encryptedObject['x-ethers'] && encryptedObject['x-ethers'].gethFilename || "UTC--error-getting-filename";
            console.log("filename: " + filename);
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - JSON.stringify(JSON.parse(encrypted), null, 2): " + JSON.stringify(JSON.parse(encrypted), null, 2));
            let jsonContent = "data:text/json;charset=utf-8," + encrypted;
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - jsonContent: " + jsonContent);
            var encodedUri = encodeURI(jsonContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", filename);
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
            this.$bvModal.hide('modal-saveprivatekeytokeystore');
          },

          async keystoreFileChange(fileName, fileList) {
            console.log(moment().format("HH:mm:ss") + " keystoreFileChange: " + JSON.stringify(fileName));
            const reader = new FileReader();
            this.wallet.keystoreFileContent = {};
            const t = this;
            reader.onload = function (event) {
              const data = event.target.result;
              t.wallet.keystoreFileContent = data;
              console.log(moment().format("HH:mm:ss") + " keystoreFileContent: " + t.wallet.keystoreFileContent);
            };
            await reader.readAsText(fileList[0]);
          },

          async testIt() {
            console.log(moment().format("HH:mm:ss") + " testIt");
            const privateKey = "{myprivatekey}";
            const wallet = new ethers.Wallet(privateKey);
            const WEENUSADDRESS = "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9";
            const interface = new ethers.utils.Interface(ERC20ABI);
            const contractWithoutProvider = new ethers.Contract(WEENUSADDRESS, interface, wallet);
            const unsignedTx = await contractWithoutProvider.populateTransaction.transfer(wallet.address, 1);
            console.log("unsignedTx: " + JSON.stringify(unsignedTx, null, 2));
            console.log("address: " + wallet.address);
            const tx = {
              from: wallet.address,
              to: "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9",
              gasLimit: 50000,
              // gasPrice: 1000000,
              type: 2,
              maxFeePerGas: 1234000,
              maxPriorityFeePerGas: 1234000,
              value: 0,
              data: unsignedTx.data,
              nonce: 36,
              chainId: 11155111,
            };
            console.log("tx: " + JSON.stringify(tx));
            const signedTx = await wallet.signTransaction(tx);
            console.log("signedTx: " + signedTx);
            const decoded = ethers.utils.parseTransaction(signedTx);
            console.log("decoded: " + JSON.stringify(decoded, null, 2));
          },

          async testItOld() {
            console.log(moment().format("HH:mm:ss") + " testIt");
            const privateKey = "{myprivatekey}";
            const wallet = new ethers.Wallet(privateKey);
            console.log("address: " + wallet.address);
            const tx = {
              from: wallet.address,
              to: "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9",
              gasLimit: 50000,
              // gasPrice: 1000000,
              type: 2,
              maxFeePerGas: 1234000,
              maxPriorityFeePerGas: 1234000,
              value: 0,
              data: "",
              nonce: 35,
              chainId: 11155111,
            };
            console.log("tx: " + JSON.stringify(tx));
            // const populatedTx = await wallet.populateTransaction(tx);
            // console.log("populatedTx: " + populatedTx);
            const sig = await wallet.signTransaction(tx);
            console.log("sig: " + sig);
          },

          // async processData(provider) {
          //   console.log(moment().format("HH:mm:ss") + " processData BEGIN");
          //   const accounts = this.accounts;
          //   const events = this.events[this.chainId] || {};
          //   for (const blockNumber of Object.keys(events).sort((a, b) => { return a - b })) {
          //     const blockNumberData = events[blockNumber];
          //     for (const logIndex of Object.keys(blockNumberData).sort((a, b) => { return a - b })) {
          //       const eventData = events[blockNumber][logIndex];
          //       const contract = eventData.contract;
          //       const account = accounts[this.chainId] && accounts[this.chainId][contract] || null;
          //       // console.log(event.blockNumber + "." + event.txIndex + "." + event.logIndex + " " + JSON.stringify(event) + " " + JSON.stringify(account));
          //       if (account) {
          //         const type = account.customType || account.type;
          //         if (type == "erc20") {
          //           if (!('approvals' in account)) {
          //             account.approvals = {};
          //           }
          //           if (!(eventData.owner in account.approvals)) {
          //             account.approvals[eventData.owner] = {};
          //           }
          //           account.approvals[eventData.owner][eventData.spender] = eventData.value;
          //         } else if (type == "erc721") {
          //           if (eventData.eventName == "Approval") {
          //             if (!('approvals' in account)) {
          //               account.approvals = {};
          //             }
          //             if (!(eventData.owner in account.approvals)) {
          //               account.approvals[eventData.owner] = {};
          //             }
          //             account.approvals[eventData.owner][eventData.value] = eventData.spender;
          //           } else if (eventData.eventName == "ApprovalForAll") {
          //             if (!('approvalsForAll' in account)) {
          //               account.approvalsForAll = {};
          //             }
          //             if (!(eventData.owner in account.approvalsForAll)) {
          //               account.approvalsForAll[eventData.owner] = {};
          //             }
          //             account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
          //           }
          //         } else if (type == "erc1155") {
          //           if (!('approvalsForAll' in account)) {
          //             account.approvalsForAll = {};
          //           }
          //           if (!(eventData.owner in account.approvalsForAll)) {
          //             account.approvalsForAll[eventData.owner] = {};
          //           }
          //           account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
          //         }
          //         Vue.set(this.accounts[this.chainId], contract, account);
          //       } else {
          //         console.log(moment().format("HH:mm:ss") + " processData - account: " + contract + " not found");
          //       }
          //     }
          //   }
          //   // Get current ERC-20 allowances as these amounts are reduced by `transferFrom(...)` calls
          //   this.sync.total = 0;
          //   for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
          //     const type = accountData.customType || accountData.type;
          //     if (type == "erc20") {
          //       for (const owner of this.accountsToSearch) {
          //         const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
          //         for (const [spender, approved] of Object.entries(approvals)) {
          //           this.sync.total++;
          //         }
          //       }
          //     }
          //   }
          //   this.sync.completed = 0;
          //   this.sync.section = 'Latest ERC-20 Allowances';
          //   for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
          //     const type = accountData.customType || accountData.type;
          //     if (type == "erc20" && !this.sync.halt) {
          //       for (const owner of this.accountsToSearch) {
          //         const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
          //         for (const [spender, approved] of Object.entries(approvals)) {
          //           const erc20Contract = new ethers.Contract(account, ERC20ABI, provider);
          //           const newValue = await erc20Contract.allowance(owner, spender);
          //           accountData.approvals[owner][spender] = newValue.toString();
          //           Vue.set(this.accounts[this.chainId], account, accountData);
          //           this.sync.completed++;
          //         }
          //       }
          //     }
          //   }
          //   if (!this.sync.halt) {
          //     localStorage.approvalAccounts = JSON.stringify(accounts);
          //     Vue.set(this, 'accounts', accounts);
          //   }
          //   this.forceRefresh++; // UI refresh workaround
          //   console.log(moment().format("HH:mm:ss") + " processData END");
          // },

          saveSettings() {
            localStorage.approvalToolSettings = JSON.stringify(this.settings);
          },
          // async processNewBlock(blockNumber) {
          //   console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          // },
          // async halt() {
          //   this.sync.halt = true;
          //   console.log(moment().format("HH:mm:ss") + " halt()");
          // },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          // formatETH(e, precision = 9) {
          //   try {
          //     if (precision == 0) {
          //       return e ? ethers.utils.formatEther(e) : null;
          //     } else {
          //       return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
          //     }
          //   } catch (err) {
          //   }
          //   return e.toFixed(precision);
          // },
          // formatDecimals(e, decimals = 18) {
          //   return e ? ethers.utils.formatUnits(e, decimals) : null;
          // },
          // formatTimestamp(ts) {
          //   if (ts != null) {
          //     if (this.settings.reportingDateTime == 1) {
          //       return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
          //     } else {
          //       return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
          //     }
          //   }
          //   return null;
          // },
          // formatTimeDiff(unixtime) {
          //   if (!unixtime) {
          //     return "";
          //   } else {
          //     return moment.unix(unixtime).fromNow();
          //   }
          // },
          // nameOrAddress(address, length = 0) {
          //   let result = null;
          //   const accounts = this.accounts[this.chainId] || {};
          //   if (address in accounts) {
          //     result = accounts[address].customName || accounts[address].name || address;
          //   } else {
          //     result = address;
          //   }
          //   if (result && length > 0) {
          //     result = result.substring(0, length);
          //   }
          //   return result;
          // },
          // addressDescription(address) {
          //   const accounts = this.accounts[this.chainId] || {};
          //   if (address in accounts) {
          //     result = "address=" + address;
          //     for (let key of ['type', 'customType', 'symbol', 'name', 'customName', 'decimals', 'customDecimals', 'source']) {
          //       if (key in accounts[address] && accounts[address][key]) {
          //         result = result + "; " + key + "=" + accounts[address][key];
          //       }
          //     }
          //   } else {
          //     result = address;
          //   }
          //   return result;
          // },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          // async connectToWeb3() {
          //   if (!window.ethereum) {
          //     this.connected = false;
          //   } else {
          //     try {
          //       const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          //       this.connected = window.ethereum.isConnected();
          //     } catch (e) {
          //       console.log("window.ethereum.request error: " + e.message);
          //       this.connected = false;
          //     }
          //   }
          //   if (!this.connected) {
          //     alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
          //   } else {
          //     const t = this;
          //     function handleChainChanged(_chainId) {
          //       t.chainId = _chainId;
          //       console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
          //       alert('Ethereum chain has changed - reloading this page.')
          //       window.location.reload();
          //     }
          //     window.ethereum.on('chainChanged', handleChainChanged);
          //     const provider = new ethers.providers.Web3Provider(window.ethereum);
          //     async function handleAccountsChanged(accounts) {
          //       const signer = provider.getSigner();
          //       t.coinbase = await signer.getAddress();
          //       console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
          //     }
          //     window.ethereum.on('accountsChanged', handleAccountsChanged);
          //     async function handleNewBlock(blockNumber) {
          //       if (!t.blockNumber || blockNumber > t.blockNumber) {
          //         const block = await provider.getBlock("latest");
          //         t.blockNumber = block.number;
          //         t.timestamp = block.timestamp;
          //         await t.processNewBlock(blockNumber);
          //       }
          //     }
          //     provider.on("block", handleNewBlock);
          //     const signer = provider.getSigner();
          //     this.coinbase = await signer.getAddress();
          //     const network = await provider.getNetwork();
          //     this.chainId = network.chainId;
          //     console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
          //   }
          // },
        },

        // --- MOUNTED ---
        mounted() {
          if ('topSecretsOfflineAddresses' in localStorage) {
            this.addresses = JSON.parse(localStorage.topSecretsOfflineAddresses);
          }

          // (async() => {
          //   await this.connectToWeb3();
          // })();
          // if ('approvalToolChainId' in localStorage) {
          //   this.chainId = localStorage.approvalToolChainId;
          // }
          // if ('approvalToolCoinbase' in localStorage) {
          //   this.coinbase = localStorage.approvalToolCoinbase;
          // }
          // if ('approvalToolSettings' in localStorage) {
          //   const tempSettings = JSON.parse(localStorage.approvalToolSettings);
          //   if ('version' in tempSettings && tempSettings.version == this.settings.version) {
          //     this.settings = tempSettings;
          //     if (this.settings.approvalsTable.currentPage > 1) {
          //       this.settings.approvalsTable.currentPage = 1;
          //     }
          //   }
          // }
        },
      })
    </script>
  </body>
</html>
