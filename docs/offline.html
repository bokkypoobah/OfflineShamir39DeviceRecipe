<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Offline:TopSecrets</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Offline:TopSecrets (c) Bok Consulting Pty Ltd 2024" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="globals.js"></script>
    <script src="customNames.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/ApprovalTool/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/topsecrets.svg" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">Offline:TopSecrets</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Addresses, including your wallets, public ETH addresses, token contracts, ...'">Addresses</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Craft Ether transactions'">ETH</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'ERC-20'">ERC-20</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 3; saveSettings();" :active="settings.tabIndex == 3" active-class="active" v-b-popover.hover="'ERC-721'">ERC-721</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 4; saveSettings();" :active="settings.tabIndex == 4" active-class="active" v-b-popover.hover="'Sign and check messages'">Messages</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 5; saveSettings();" :active="settings.tabIndex == 5" active-class="active" v-b-popover.hover="'Explore Mnemonic and Private Key Wallets'">Wallet</b-nav-item>
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'Accounts'">Accounts</b-nav-item> -->
            <!-- <b-avatar v-if="coinbase && coinbase != nameOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + nameOrAddress(coinbase, 100)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar> -->
            <!-- <b-button size="sm" variant="outline-primary" class="ml-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? nameOrAddress(coinbase, 16) : 'Connect' }}</b-button> -->
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert size="sm" dismissible variant="warning" show class="m-1 mb-0 my-0">
            Warning: This is experimental unaudited work-in-progress software. This dapp is meant for use on permanently offline computers.
          </b-alert>
          <b-card v-if="false" class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Mainnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <!-- :MODALGENERATEMNEMONIC -->
          <b-modal id="modal-generatemnemonic" hide-footer size="sm">
            <template #modal-title>
              Generate New Mnemonic
            </template>
            <b-form-group label="Number of words:" label-for="modal-generatemnemonic-numberofwords" label-size="sm" label-cols-sm="6" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-select size="sm" id="modal-generatemnemonic-numberofwords" v-model="wallet.randomBytesLength" :options="randomBytesLengthMnemonicWordsOptions"></b-form-select>
            </b-form-group>
            <b-form-group label="" label-for="modal-generatemnemonic-generate" label-size="sm" label-cols-sm="6" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="modal-generatemnemonic-generate" @click="generateRandomMnemonic()" variant="primary">Generate</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALLOADPRIVATEKEYFROMKEYSTORE -->
          <b-modal id="modal-loadprivatekeyfromkeystore" hide-footer size="lg">
            <template #modal-title>
              Load Private Key From JSON/UTC Keystore
            </template>
            <b-form-group label="Keystore File:" label-for="modal-loadprivatekeyfromkeystore-keystorefile" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Select encrypted keystore (JSON/UTC) file from your local computer'" class="mx-0 my-1 p-0">
              <b-form-file size="sm" id="modal-loadprivatekeyfromkeystore-keystorefile" v-model="wallet.keystoreFile" @change="keystoreFileChange($event.target.name, $event.target.files)"></b-form-file>
            </b-form-group>
            <b-form-group label="Password:" label-for="modal-loadprivatekeyfromkeystore-keystorefilepassword" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="password" autocomplete="current-password" size="sm" id="modal-loadprivatekeyfromkeystore-keystorefilepassword" v-model.trim="wallet.keystoreFilePassword" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="modal-loadprivatekeyfromkeystore-load" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="modal-loadprivatekeyfromkeystore-load" @click="loadPrivateKeyFromKeystore()" variant="primary">Load</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALSAVEPRIVATEKEYTOKEYSTORE -->
          <b-modal id="modal-saveprivatekeytokeystore" hide-footer size="md">
            <template #modal-title>
              Save Private Key To JSON/UTC Keystore
            </template>
            <b-form-group label="Keystore File Password:" label-for="modal-saveprivatekeytokeystore-password" label-size="sm" label-cols-sm="5" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="password" autocomplete="current-password" size="sm" id="modal-saveprivatekeytokeystore-password" v-model="wallet.keystoreFilePassword"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="modal-saveprivatekeytokeystore-save" label-size="sm" label-cols-sm="5" label-align-sm="right" description="Encrypting will take around half a minute" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!wallet.keystoreFilePassword" id="modal-saveprivatekeytokeystore-save" @click="savePrivateKeyToKeystore()" variant="primary">Save</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWWALLETFROMMNEMONIC -->
          <b-modal id="modal-newwalletfrommnemonic" hide-footer size="lg">
            <template #modal-title>
              New Wallet From Mnemonic Seed Phrase
            </template>
            <b-form-group label="Phrase:" label-for="newwalletfrommnemonic-mnemonicphrase" label-size="sm" label-cols-sm="3" label-align-sm="right" :state="!newWalletFromMnemonic.phraseError" :invalid-feedback="newWalletFromMnemonic.phraseError" class="mx-0 my-2 p-0">
              <b-form-textarea size="sm" id="newwalletfrommnemonic-mnemonicphrase" v-model.trim="newWalletFromMnemonic.phrase" @change="newWalletFromMnemonicRecompute();" debounce="600" rows="3" placeholder="Type/paste your mnemnonic seed phrase here or click [Generate Random]" style="max-width: 800px;"></b-form-textarea>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfrommnemonic-generaterandom" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group style="max-width: 300px;">
                <b-form-select size="sm" v-model="newWalletFromMnemonic.randomBytesLength" :options="randomBytesLengthMnemonicWordsOptions"></b-form-select>
                <b-input-group-append>
                  <b-button size="sm" id="newwalletfrommnemonic-generaterandom" @click="newWalletFromMnemonicGenerateRandom()" variant="primary">Generate Random</b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="Passphrase:" label-for="newwalletfrommnemonic-mnemonicpassphrase" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-2 p-0">
              <b-form-input type="text" size="sm" id="newwalletfrommnemonic-mnemonicpassphrase" v-model.trim="newWalletFromMnemonic.passphrase" placeholder="Optional" debounce="600" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Derivation Path:" label-for="newwalletfrommnemonic-derivationpath" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-2 p-0">
              <b-form-select size="sm" id="newwalletfrommnemonic-derivationpath" v-model.trim="newWalletFromMnemonic.derivationPath" :options="derivationPathOptions" style="max-width: 300px;" v-b-popover.hover.bottom="'Derivation Path'"></b-form-select>
            </b-form-group>
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-form-spinbutton size="sm" v-model="newWalletFromMnemonic.page" min="0" inline v-b-popover.hover.bottom="'Page'"></b-form-spinbutton>
              </div>
              <div class="mt-0">
                <b-form-select size="sm" v-model="newWalletFromMnemonic.pageSize" :options="indexPageSizeOptions" v-b-popover.hover.bottom="'Page Size'"></b-form-select>
              </div>
            </div>
            <b-table ref="newWalletFromMnemonicAddressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='newWalletFromMnemonicAddressesRowSelected' :fields="newWalletFromMnemonicAddressesFields" :items="newWalletFromMnemonicAddresses" show-empty empty-html="Enter information above" head-variant="light" class="mx-0 my-1">
              <template #cell(index)="data">
                <font size="-1">
                  {{ data.item.index }}
                </font>
              </template>
              <template #cell(path)="data">
                <font size="-1">
                  {{ data.item.path }}
                </font>
              </template>
              <template #cell(address)="data">
                <font size="-1">
                  {{ data.item.address }}
                </font>
              </template>
              <template #cell(privateKey)="data">
                <font size="-1">
                  {{ data.item.privateKey.substring(0, 10) + '...' + data.item.privateKey.slice(-8) }}
                </font>
              </template>
            </b-table>
          </b-modal>

          <!-- :MODALNEWWALLETFROMMNEMONICADD -->
          <b-modal id="modal-newwalletfrommnemonic-add" hide-footer size="lg">
            <template #modal-title>
              Add New Wallet From Mnemonic Seed Phrase
            </template>
            <b-form-group v-if="newWalletFromMnemonic.selectedItem" label="Path:" label-for="newwalletfrommnemonic-add-path" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfrommnemonic-add-path" :value="newWalletFromMnemonic.selectedItem.path" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="newWalletFromMnemonic.selectedItem" label="ETH Address:" label-for="newwalletfrommnemonic-add-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfrommnemonic-add-address" :value="newWalletFromMnemonic.selectedItem.address" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="newWalletFromMnemonic.selectedItem" label="Private Key:" label-for="newwalletfrommnemonic-add-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfrommnemonic-add-privatekey" v-model="newWalletFromMnemonic.selectedItem.privateKey" style="max-width: 600px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="newwalletfrommnemonic-add-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfrommnemonic-add-name" v-model.trim="newWalletFromMnemonic.name" debounce="600" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>

            <b-form-group label="Password:" label-for="newwalletfrommnemonic-password" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Password to encrypt this wallet within this dapp" class="mx-0 my-1 p-0">
              <b-form-input type="password" size="sm" id="newwalletfrommnemonic-password" v-model.trim="newWalletFromMnemonic.password" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Confirm Password:" label-for="newwalletfrommnemonic-confirmpassword" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Confirm password above" class="mx-0 my-1 p-0">
              <b-form-input type="password" size="sm" id="newwalletfrommnemonic-confirmpassword" v-model.trim="newWalletFromMnemonic.confirmPassword" style="max-width: 300px;"></b-form-input>
            </b-form-group>

            <b-form-group label="" label-for="newwalletfrommnemonic-add-add" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!newWalletFromMnemonic.selectedItem || !newWalletFromMnemonic.selectedItem.address || !newWalletFromMnemonic.password || (newWalletFromMnemonic.password != newWalletFromMnemonic.confirmPassword)" id="newwalletfrommnemonic-add-add" @click="newWalletFromMnemonicAdd()" variant="primary">Add</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWWALLETFROMPRIVATEKEY -->
          <b-modal id="modal-newwalletfromprivatekey" hide-footer size="lg">
            <template #modal-title>
              New Wallet From Private Key
            </template>
            <b-form-group label="Private Key:" label-for="newwalletfromprivatekey-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" :state="!newWalletFromPrivateKey.privateKeyError" :invalid-feedback="newWalletFromPrivateKey.privateKeyError" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfromprivatekey-privatekey" v-model.trim="newWalletFromPrivateKey.privateKey" @change="newWalletFromPrivateKeyRecompute();" placeholder="Type/paste your private key here or click [Generate New]" style="max-width: 600px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromprivatekey-generaterandom" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="newwalletfromprivatekey-generaterandom" @click="newWalletFromPrivateKeyGenerateRandom()" variant="primary">Generate Random</b-button>
            </b-form-group>
            <b-form-group label="ETH Address:" label-for="newwalletfromprivatekey-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfromprivatekey-address" :value="newWalletFromPrivateKey.address" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="newwalletfromprivatekey-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfromprivatekey-name" v-model.trim="newWalletFromPrivateKey.name" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Password:" label-for="newwalletfromprivatekey-password" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Password to encrypt this wallet within this dapp" class="mx-0 my-1 p-0">
              <b-form-input type="password" size="sm" id="newwalletfromprivatekey-password" v-model.trim="newWalletFromPrivateKey.password" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Confirm Password:" label-for="newwalletfromprivatekey-confirmpassword" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Confirm password above" class="mx-0 my-1 p-0">
              <b-form-input type="password" size="sm" id="newwalletfromprivatekey-confirmpassword" v-model.trim="newWalletFromPrivateKey.confirmPassword" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromprivatekey-add" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Encrypting will take around half a minute" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!newWalletFromPrivateKey.address || !newWalletFromPrivateKey.password || (newWalletFromPrivateKey.password != newWalletFromPrivateKey.confirmPassword)" id="newwalletfromprivatekey-add" @click="newWalletFromPrivateKeyAdd()" variant="primary">Add</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWWALLETFROMKEYSTORE -->
          <b-modal id="modal-newwalletfromkeystore" hide-footer size="lg">
            <template #modal-title>
              New Wallet From JSON/UTC Keystore Private Key
            </template>
            <b-form-group label="Keystore File:" label-for="newwalletfromkeystore-keystorefile" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="'Select encrypted keystore (JSON/UTC) file from your local computer'" class="mx-0 my-1 p-0">
              <b-form-file size="sm" id="newwalletfromkeystore-keystorefile" v-model="newWalletFromKeystore.keystoreFile" @change="newWalletFromKeystoreFileChange($event.target.name, $event.target.files)"></b-form-file>
            </b-form-group>
            <b-form-group label="Password:" label-for="newwalletfromkeystore-keystorefilepassword" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="password" autocomplete="current-password" size="sm" id="newwalletfromkeystore-keystorefilepassword" v-model="newWalletFromKeystore.keystoreFilePassword" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromkeystore-load" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!newWalletFromKeystore.keystoreFile" id="newwalletfromkeystore-load" @click="newWalletFromKeystoreLoad()" variant="primary">Load</b-button>
            </b-form-group>
            <b-form-group label="Private Key:" label-for="newwalletfromkeystore-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfromkeystore-privatekey" v-model="newWalletFromKeystore.privateKey" style="max-width: 600px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Address:" label-for="newwalletfromkeystore-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfromkeystore-address" :value="newWalletFromKeystore.address" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="newwalletfromkeystore-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfromkeystore-name" v-model.trim="newWalletFromKeystore.name" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Password:" label-for="newwalletfromkeystore-password" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Password to encrypt this wallet within this dapp" class="mx-0 my-1 p-0">
              <b-form-input type="password" size="sm" id="newwalletfromkeystore-password" v-model.trim="newWalletFromKeystore.password" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Confirm Password:" label-for="newwalletfromkeystore-confirmpassword" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Confirm password above" class="mx-0 my-1 p-0">
              <b-form-input type="password" size="sm" id="newwalletfromkeystore-confirmpassword" v-model.trim="newWalletFromKeystore.confirmPassword" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromkeystore-add" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!newWalletFromKeystore.address || !newWalletFromKeystore.password || (newWalletFromKeystore.password != newWalletFromKeystore.confirmPassword)" id="newwalletfromkeystore-add" @click="newWalletFromKeystoreAdd()" variant="primary">Add</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALADDRESS -->
          <b-modal id="modal-address" hide-footer size="lg">
            <template #modal-title>
              {{ address.mode == 'add' ? 'New' : ''}} Address
            </template>
            <b-form-group label="Type:" label-for="address-type" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-select size="sm" :disabled="['walletfrommnemonic', 'walletfromprivatekey', 'walletfromkeystore'].includes(address.type)" id="address-type" v-model="address.type" :options="addressTypeOptions" style="max-width: 300px;"></b-form-select>
            </b-form-group>
            <b-form-group label="Address:" label-for="address-address" label-size="sm" label-cols-sm="3" label-align-sm="right" :state="!address.addressError" :invalid-feedback="address.addressError" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" :readonly="address.mode != 'add'" id="address-address" v-model.trim="address.address" @change="newAddressRecompute();" style="max-width: 400px;"></b-form-input>
            </b-form-group>

            <b-form-group v-if="address.mode == 'vieworupdate' && !address.privateKey && ['walletfrommnemonic', 'walletfromprivatekey', 'walletfromkeystore'].includes(address.type)" label="Private Key" label-for="address-privatekeypassword" label-size="sm" label-cols-sm="3" label-align-sm="right" :state="!address.passwordError" :invalid-feedback="address.passwordError" class="mx-0 my-1 p-0">
              <b-form-input type="password" size="sm" id="address-privatekeypassword" v-model.trim="address.password" @change="addressPrivateKeyPasswordUpdate();" placeholder="Enter password" debounce="600" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="address.mode == 'vieworupdate' && address.privateKey && ['walletfrommnemonic', 'walletfromprivatekey', 'walletfromkeystore'].includes(address.type)" label="Private Key" label-for="address-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="address-privatekey" v-model.trim="address.privateKey" style="max-width: 600px;"></b-form-input>
            </b-form-group>

            <b-form-group label="Name:" label-for="address-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="address-name" v-model.trim="address.name" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="address.mode == 'add'" label="" label-for="address-add" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!address.address" id="address-add" @click="addressAdd()" variant="primary">Add</b-button>
            </b-form-group>
            <b-form-group v-if="address.mode == 'vieworupdate'" label="" label-for="address-update" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!address.address" id="address-update" @click="addressUpdate()" variant="primary">Update</b-button>
              <b-button size="sm" :disabled="!address.address" @click="addressDelete()" variant="warning">Delete</b-button>
            </b-form-group>
          </b-modal>

          <!-- :ADDRESSES -->
          <b-card v-if="settings.tabIndex == 0" class="m-0 p-0 border-0" body-class="m-1 p-0">
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-dropdown size="sm" variant="link" v-b-popover.hover.bottom="'New Address'">
                  <template #button-content>
                    <b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus>
                  </template>
                  <b-dropdown-item @click="showNewWalletFromMnemonic">New Wallet From Mnemonic</b-dropdown-item>
                  <b-dropdown-item @click="showNewWalletFromPrivateKey">New Wallet From Private Key</b-dropdown-item>
                  <b-dropdown-item @click="showNewWalletFromKeystore">New Wallet From Keystore</b-dropdown-item>
                  <b-dropdown-item @click="showAddressNew">New Address</b-dropdown-item>
                </b-dropdown>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pl-1">
                <font size="-2" v-b-popover.hover.bottom="'# addresses'">{{ commify0(addresses.length) }}</font>
              </div>
              <div class="mt-0 pl-1">
                <b-pagination size="sm" v-model="settings.addressesTable.currentPage" @input="saveSettings" :total-rows="filteredSortedAddresses.length" :per-page="settings.addressesTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.addressesTable.pageSize" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
              </div>
            </div>
            <b-table ref="addressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='addressesRowSelected' :fields="addressesFields" :items="pagedFilteredSortedWallets" show-empty empty-html="Add new wallets" head-variant="light" class="mx-0 my-1">
              <template #cell(number)="data">
                <font size="-1">
                  {{ parseInt(data.index) + ((settings.addressesTable.currentPage - 1) * settings.addressesTable.pageSize) + 1 }}
                </font>
              </template>
              <template #cell(type)="data">
                <b-badge pill variant="transparent" class="px-0">{{ addressTypeOptions.filter(e => e.value == data.item.type)[0].text }}</b-badge>
              </template>
            </b-table>
          </b-card>

          <!-- :ETH -->
          <b-card v-if="settings.tabIndex == 1" class="m-0 p-0 border-0" body-class="m-1 p-0">
            <!-- :SIGNETHTX -->
            <b-card sub-title="Sign ETH Transaction" bg-variant="light" class="p-0 m-1" style="max-width: 800px;">
              <b-form-group label="From:" label-for="signethtx-from" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-select size="sm" id="signethtx-from" v-model="signEthTx.from" :options="addressesOptions" v-b-popover.hover.bottom="'Select Wallet'"></b-form-select>
              </b-form-group>
              <b-form-group label="To:" label-for="signethtx-to" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="signethtx-to" v-model.trim="signEthTx.to" placeholder="Optional for contract deployment" style="max-width: 500px;"></b-form-input>
              </b-form-group>
              <b-form-group label="Amount:" label-for="signethtx-amount" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-input-group style="max-width: 300px;">
                  <b-form-input type="text" size="sm" id="signethtx-amount" v-model.trim="signEthTx.amount" style="max-width: 200px;"></b-form-input>
                  <b-input-group-append>
                    <b-form-select size="sm" v-model="signEthTx.amountUnit" :options="unitOptions"></b-form-select>
                  </b-input-group-append>
                </b-input-group>
              </b-form-group>
              <b-form-group label="Data:" label-for="signethtx-data" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-1 p-0">
                <b-form-textarea size="sm" id="signethtx-data" v-model="signEthTx.data" rows="3" placeholder="Optional, 0x{hex}" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
              <b-form-group label="Nonce:" label-for="signethtx-nonce" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="signethtx-nonce" v-model.trim="signEthTx.nonce" placeholder="Latest unused" style="max-width: 150px;"></b-form-input>
              </b-form-group>
              <!-- <b-form-group label="Message:" label-for="signmessage-message" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" id="signmessage-message" v-model.trim="signMessage.message" rows="3" placeholder="Type/paste your message here, then click [Sign]" style="max-width: 800px;"></b-form-textarea>
              </b-form-group> -->
              <!-- <b-form-group label="" label-for="signmessage-sign" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="!signMessage.wallet || !signMessage.message" id="signmessage-sign" @click="signMessageSign()" variant="primary">Sign</b-button>
              </b-form-group> -->
              <!-- <b-form-group label="Signature:" label-for="signmessage-signature" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" readonly id="signmessage-signature" v-model.trim="signMessage.signature" rows="3" placeholder="Click [Sign]" style="max-width: 800px;"></b-form-textarea>
              </b-form-group> -->
            </b-card>
            <!-- TODO: Send ETH tx, with data field -->
            <b-form-group label="Test:" label-for="wallet-testit" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="wallet-testit" @click="testIt()" variant="warning">Test</b-button>
            </b-form-group>
          </b-card>

          <!-- :ERC20 -->
          <b-card v-if="settings.tabIndex == 2" class="m-0 p-0 border-0" body-class="m-1 p-0">
            TODO: ERC-20 Functions - approve, transfer, transferFrom
          </b-card>

          <!-- :ERC721 -->
          <b-card v-if="settings.tabIndex == 3" class="m-0 p-0 border-0" body-class="m-1 p-0">
            TODO: ERC-721 Functions - *approv*, *transfer*
          </b-card>

          <!-- :MESSAGES -->
          <b-card v-if="settings.tabIndex == 4" class="m-0 p-0 border-0" body-class="m-1 p-0">
            <!-- :SIGNMESSAGE -->
            <b-card sub-title="Sign Message" bg-variant="light" class="p-0 m-1" style="max-width: 800px;">
              <b-form-group label="Wallet:" label-for="signmessage-wallet" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                <b-form-select size="sm" id="signmessage-wallet" v-model="signMessage.wallet" :options="addressesOptions" v-b-popover.hover.bottom="'Select Wallet'"></b-form-select>
              </b-form-group>
              <b-form-group label="Message:" label-for="signmessage-message" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" id="signmessage-message" v-model.trim="signMessage.message" rows="3" placeholder="Type/paste your message here, then click [Sign]" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
              <b-form-group label="" label-for="signmessage-sign" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="!signMessage.wallet || !signMessage.message" id="signmessage-sign" @click="signMessageSign()" variant="primary">Sign</b-button>
              </b-form-group>
              <b-form-group label="Signature:" label-for="signmessage-signature" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" readonly id="signmessage-signature" v-model.trim="signMessage.signature" rows="3" placeholder="Click [Sign]" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
            </b-card>

            <!-- :CHECKMESSAGE -->
            <b-card sub-title="Check Message" bg-variant="light" class="p-0 m-1" style="max-width: 800px;">
              <b-form-group label="Message:" label-for="checkmessage-message" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" id="checkmessage-message" v-model="checkMessage.message" rows="3" placeholder="Type/paste your message here, then click [Sign]" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
              <b-form-group label="Signature:" label-for="checkmessage-signature" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" id="checkmessage-signature" v-model="checkMessage.signature" rows="3" placeholder="Paste your signature here" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
              <b-form-group label="Recovered Address:" label-for="checkmessage-recoveredaddress" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-3 p-0">
                <b-form-input type="text" size="sm" readonly id="checkmessage-recoveredaddress" :value="checkMessageRecoveredAddress" style="max-width: 500px;"></b-form-input>
              </b-form-group>
            </b-card>

          </b-card>

          <b-card v-if="settings.tabIndex == 5" class="m-0 p-0 border-0" body-class="m-1 p-0">
            <b-form-group label-cols-lg="1" label="Wallet" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-card bg-variant="light" no-body class="p-0 m-1">
                <b-tabs card align="left" no-body v-model="wallet.tab" active-tab-class="m-0 p-0">
                  <b-tab v-for="t in tabs" :key="'dyn-tabx-' + t.name" @click="updateURL(t.name);" :title="t.text" title-item-class="p-0" title-link-class="mt-2 px-3">
                  </b-tab>
                </b-tabs>
                <b-card-text class="m-0 p-2">
                  <b-form-group v-if="wallet.tab == 0" label="Phrase:" label-for="wallet-mnemonicphrase" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                    <b-form-textarea size="sm" id="wallet-mnemonicphrase" v-model="wallet.mnemonic.phrase" @change="generateDerivedAddresses();" rows="3" placeholder="Type/paste your mnemnonic seed phrase here or click [Generate New]" style="max-width: 800px;"></b-form-textarea>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 0" label="" label-for="wallet-showgeneratemnemonicmodal" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="wallet-showgeneratemnemonicmodal" @click="showGenerateMnemonicModal()" variant="primary">Generate New</b-button>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 0" label="Passphrase:" label-for="wallet-mnemonicpassphrase" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                    <b-form-input type="text" size="sm" id="wallet-mnemonicpassphrase" v-model="wallet.mnemonic.passphrase" @change="generateDerivedAddresses();" placeholder="Optional" style="max-width: 300px;"></b-form-input>
                  </b-form-group>
                  <b-card v-if="wallet.tab == 0" class="m-0 mt-2 p-0 border-0" body-class="m-1 p-0">
                    <div class="d-flex flex-wrap m-0 p-0">
                      <div class="mt-1 pl-1">
                        <font size="-1">Derivation Path:</font>
                      </div>
                      <div class="mt-0 pl-1">
                        <b-form-select size="sm" v-model="wallet.derivationPath" :options="derivationPathOptions" @change="generateDerivedAddresses();" style="max-width: 300px;" v-b-popover.hover.bottom="'Derivation Path'"></b-form-select>
                      </div>
                      <div class="mt-0 flex-grow-1">
                      </div>
                      <div class="mt-1 pr-1">
                        <font size="-1">Start:</font>
                      </div>
                      <div class="mt-0 pr-1">
                        <b-form-input type="number" size="sm" v-model="wallet.indexStart" min="0" @change="generateDerivedAddresses();" style="max-width: 100px;" v-b-popover.hover.bottom="'Index Start'"></b-form-input>
                      </div>
                      <div class="mt-0">
                        <b-form-select size="sm" v-model="wallet.indexCount" :options="indexPageSizeOptions" @change="generateDerivedAddresses();"></b-form-select>
                      </div>
                    </div>
                    <b-table ref="addressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='generatedAddressesRowSelected':fields="generatedAddressesFields" :items="generatedAddresses" show-empty empty-html="Enter information above" head-variant="light" class="mx-0 my-1">
                      <template #cell(index)="data">
                        <font size="-1">
                          {{ data.item.index }}
                        </font>
                      </template>
                      <template #cell(path)="data">
                        <font size="-1">
                          {{ data.item.path }}
                        </font>
                      </template>
                      <template #cell(address)="data">
                        <font size="-1">
                          {{ data.item.address }}
                        </font>
                      </template>
                      <template #cell(privateKey)="data">
                        <font size="-1">
                          {{ data.item.privateKey }}
                        </font>
                      </template>
                    </b-table>
                  </b-card>
                  <b-form-group v-if="wallet.tab == 1" label="Private Key:" label-for="wallet-privatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.privateKeyError" :invalid-feedback="wallet.privateKeyError" class="mx-0 my-2 p-0">
                    <b-form-input type="text" size="sm" id="wallet-privatekey" v-model="wallet.privateKey" @change="recomputeFromPrivateKey();" placeholder="Type/paste your private key here, click [Generate New] or [Load From Keystore]" class="w-75"></b-form-input>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 1" label="" label-for="wallet-generaterandomprivatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="wallet-generaterandomprivatekey" @click="generateRandomPrivateKey()" variant="primary">Generate New</b-button>
                    <b-button size="sm" @click="showLoadPrivateKeyFromKeystoreModal()" variant="primary">Load From Keystore</b-button>
                    <b-button size="sm" :disabled="!wallet.privateKey || !!wallet.privateKeyError" @click="showSavePrivateKeyToKeystoreModal()" variant="primary">Save To Keystore</b-button>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 1" label="ETH Address:" label-for="output-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-3 p-0">
                    <b-form-input type="text" size="sm" readonly id="output-address" :value="wallet.address" class="w-50"></b-form-input>
                  </b-form-group>
                  <b-form-group v-if="false && wallet.tab == 0" label="Debug Addresses:" label-for="debug-addresses-textarea" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 mt-3 p-0">
                    <b-form-textarea size="sm" readonly id="debug-addresses-textarea" :value="JSON.stringify(generatedAddresses, null, 2)" rows="3" max-rows="10" class="w-100"></b-form-textarea>
                  </b-form-group>
                  <b-form-group v-if="false" label="Debug:" label-for="debug-textarea" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 mt-3 p-0">
                    <b-form-textarea size="sm" readonly id="debug-textarea" :value="JSON.stringify(wallet, null, 2)" rows="3" max-rows="10" class="w-100"></b-form-textarea>
                  </b-form-group>
                  <b-form-group v-if="false" label="Test:" label-for="wallet-testit" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="wallet-testit" @click="testIt()" variant="warning">Test</b-button>
                  </b-form-group>
                </b-card-text>
              </b-card>
            </b-form-group>
          </b-card>

        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="false && connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>Offline:TopSecrets</i> &copy; Bok Consulting Pty Ltd 2024
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          wallet: {
            tab: 0, // 0: 'mnemonic', 1: 'privatekey'

            type: 'mnemonic', // 'mnemonic', 'privatekey'
            wallet: null, // HDNode for type 'mnemonic', Wallet for type 'privatekey'

            mnemonic: {
              phrase: null,
              phraseError: null,
              passphrase: null,
              path: "m/44'/60'/0'/0/0", // null,
              locale: null,
            },

            derivationPath: "m/44'/60'/0'/0/{index}",
            indexStart: 0,
            indexCount: 10,

            keystoreFile: null,
            keystoreFilePassword: null,
            keystoreFileContent: null,

            privateKey: null,
            privateKeyError: null,

            randomBytesLength: 16, // 12 words

            publicKey: null,
            compressedPublicKey: null,
            address: null,

            hiddenUsername: null, // For HTML accessibility
          },

          newWalletFromMnemonic: {
            phrase: null,
            randomBytesLength: 16, // 12 words
            phraseError: null,
            passphrase: null,
            derivationPath: "m/44'/60'/0'/0/{index}",
            page: 0,
            pageSize: 10,
            selectedItem: null,
            name: null,
            // path: "m/44'/60'/0'/0/0", // null,
            // locale: null,
            password: null,
            confirmPassword: null,
          },

          newWalletFromPrivateKey: {
            privateKey: null,
            privateKeyError: null,
            address: null,
            name: null,
            password: null,
            confirmPassword: null,
          },

          newWalletFromKeystore: {
            keystoreFile: null,
            keystoreFilePassword: null,
            keystoreFileContent: null,
            privateKey: null,
            address: null,
            name: null,
            password: null,
            confirmPassword: null,
          },

          address: {
            mode: 'vieworupdate', // TODO: 'add' or 'vieworupdate'
            type: null,
            address: null,
            addressError: null,
            name: null,
            keystore: null,
            password: null,
            passwordError: null,
            privateKey: null,
          },

          signMessage: {
            wallet: null,
            message: null,
            signature: null,
          },

          checkMessage: {
            message: null,
            signature: null,
          },

          signEthTx: {
            from: null,
            to: null,
            amount: null,
            amountUnit: "ethers",
            data: null,
            nonce: null,
            signature: null,
          },

          generatedAddresses: [],
          selectedAddress: null,

          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,
          forceRefresh: 0,

          settings: {
            tabIndex: 0,
            addressesTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'addressasc',
            },
            version: 12,
          },
          addresses: {},
          // sync: {
          //   section: null,
          //   total: null,
          //   completed: null,
          //   halt: false,
          // },

          tabs: [
            { name: 'mnemonic', text: 'Mnemonic Seed Phrase' },
            { name: 'privatekey', text: 'Private Key' },
          ],

          addressTypeOptions: [
            { value: 'walletfrommnemonic', text: 'Wallet From Mnemonic', disabled: true },
            { value: 'walletfromprivatekey', text: 'Wallet From Private Key', disabled: true },
            { value: 'walletfromkeystore', text: 'Wallet From Keystore', disabled: true },
            { value: 'address', text: 'Address' },
            { value: 'erc20', text: 'ERC-20 Token Contract' },
            { value: 'erc721', text: 'ERC-721 Token Contract' },
            { value: 'contract', text: 'Contract' },
          ],

          randomBytesLengthMnemonicWordsOptions: [
            { value: 16, text: '12 Words' },
            { value: 20, text: '15 Words' },
            { value: 24, text: '18 Words' },
            { value: 28, text: '21 Words' },
            { value: 32, text: '24 Words' },
          ],

          unitOptions: [
            { value: "ethers", text: 'Ethers' },
            { value: "gwei", text: 'Gwei' },
            { value: "wei", text: 'Wei' },
          ],

          // MM HW Paths
          // Ledger Live
          // Legacy (MEW/MyCrypto)
          // BIP44 Standard (e.g. MetaMask, Trezor)
          derivationPathOptions: [
            { value: "m/44'/60'/0'/0/{index}", text: "BIP-44 m/44'/60'/0'/0/{index}" },
            { value: "m/44'/60'/0'/0/{index}", text: "Legacy (MEW/MyCrypto) m/44'/60'/0'/0/{index}" }, // TODO: Check difference in MM settings with Ledger
            { value: "m/44'/60'/0'/{index}/0", text: "Test-1 m/44'/60'/0'/{index}/0" },
            { value: "m/44'/60'/0'/0/{index}/0", text: "Test-2 m/44'/60'/0'/0/{index}/0" },
          ],

          indexPageSizeOptions: [
            { value: 1, text: '1' },
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
          ],

          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],

          newWalletFromMnemonicAddressesFields: [
            { key: 'index', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'path', label: 'Path', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'privateKey', label: 'Private Key', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
          ],

          generatedAddressesFields: [
            { key: 'index', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'path', label: 'Path', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'privateKey', label: 'Private Key', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-left' },
          ],

          addressesFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-truncate' },
          ],

        },

        // --- COMPUTED ---
        computed: {

          addressesOptions() {
            const results = [];
            results.push({ value: null, text: "(Select)" });
            for (const [address, data] of Object.entries(this.addresses)) {
              results.push({ value: address, text: address + (data.name ? (" " + data.name) : "") });
            }
            return results;
          },

          checkMessageRecoveredAddress() {
            let result = null;
            if (this.checkMessage.message && this.checkMessage.signature) {
              try {
                console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress - message: " + this.checkMessage.message);
                let pubKey = ethers.utils.recoverPublicKey(ethers.utils.arrayify(ethers.utils.hashMessage(this.checkMessage.message)), this.checkMessage.signature);
                result = ethers.utils.computeAddress(pubKey);
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress ERROR: " + e.message);
              }
            }
            return result;
          },

          newWalletFromMnemonicAddresses() {
            const results = [];
            if (this.newWalletFromMnemonic.phrase) {
              try {
                const node = ethers.utils.HDNode.fromMnemonic(this.newWalletFromMnemonic.phrase, this.newWalletFromMnemonic.passphrase);
                for (let i = 0; i < this.newWalletFromMnemonic.pageSize; i++) {
                  const index = parseInt(i) + (this.newWalletFromMnemonic.page * this.newWalletFromMnemonic.pageSize);
                  let path = this.newWalletFromMnemonic.derivationPath.replace(/{index}/, index);
                  console.log("index: " + index + " => " + path);
                  const w = node.derivePath(path);
                  results.push({
                    index,
                    path,
                    privateKey: w.privateKey,
                    address: w.address,
                    // publicKey: w.publicKey,
                    // compressedPublicKey: ethers.utils.computePublicKey(w.publicKey, true),
                  });
                }
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAddresses ERROR: " + e.message);
              }
            }
            return results;
          },

          filteredAddresses() {
            // console.log(moment().format("HH:mm:ss") + " filteredAddresses: " + JSON.stringify(this.addresses));
            // let results = this.forceRefresh % 2 == 0 ? [] : [];
            const results = [];
            for (const [address, data] of Object.entries(this.addresses)) {
              results.push({
                address,
                type: data.type,
                keystore: data.keystore,
                name: data.name,
              });
            }
            return results;
          },
          filteredSortedAddresses() {
            let results = this.filteredAddresses;
          //   if (this.settings.accountsTable.sortOption == 'typenameasc') {
          //     results.sort((a, b) => {
          //       const typeA = a.customType || a.type;
          //       const typeB = b.customType || b.type;
          //       const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
          //       const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
          //       if (sortIndexA == sortIndexB) {
          //         const namea = a.customName || a.name;
          //         const nameb = b.customName || b.name;
          //         return ('' + namea).localeCompare(nameb);
          //       } else {
          //         return sortIndexA - sortIndexB;
          //       }
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'typenamedsc') {
          //     results.sort((a, b) => {
          //       const typeA = a.customType || a.type;
          //       const typeB = b.customType || b.type;
          //       const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
          //       const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
          //       if (sortIndexA == sortIndexB) {
          //         const namea = a.customName || a.name;
          //         const nameb = b.customName || b.name;
          //         return ('' + nameb).localeCompare(namea);
          //       } else {
          //         return sortIndexB - sortIndexA;
          //       }
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'nameasc') {
          //     results.sort((a, b) => {
          //       return ('' + a.name).localeCompare(b.name);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'namedsc') {
          //     results.sort((a, b) => {
          //       return ('' + b.name).localeCompare(a.name);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'addressasc') {
          //     results.sort((a, b) => {
          //       return ('' + a.address).localeCompare(b.address);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'addressdsc') {
          //     results.sort((a, b) => {
          //       return ('' + b.address).localeCompare(a.address);
          //     });
          //   }
            return results;
          },
          pagedFilteredSortedWallets() {
            console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedWallets - results[0..1]: " + JSON.stringify(this.filteredSortedAddresses.slice(0, 2), null, 2));
            return this.filteredSortedAddresses.slice((this.settings.addressesTable.currentPage - 1) * this.settings.addressesTable.pageSize, this.settings.addressesTable.currentPage * this.settings.addressesTable.pageSize);
          },

          accountsToSearch() {
            return this.settings.searchAttachedAccount ? [ this.coinbase ] : (this.settings.searchAccounts && this.settings.searchAccounts.split(/[, \t\n]+/).filter(name => name.match(/0x[0-9a-fA-F]{40}/)) || []);
          },
        },

        // --- METHODS ---
        methods: {

          updateURL(where) {
            console.log(moment().format("HH:mm:ss") + " TODO updateURL: " + where);
          },

          addressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " addressesRowSelected: " + JSON.stringify(item));
            if (item && item.length > 0) {
              this.address.mode = 'vieworupdate';
              this.address.type = item[0].type;
              this.address.address = item[0].address;
              this.address.addressError = null;
              this.address.name = item[0].name;
              this.address.keystore = item[0].keystore;
              this.address.password = null;
              this.address.privateKey = null;
              console.log(moment().format("HH:mm:ss") + " addressesRowSelected - this.address: " + JSON.stringify(this.address));
              this.$refs.addressesTable.clearSelected();
            }
            this.$bvModal.show('modal-address');
          },

          generatedAddressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " generatedAddressesRowSelected: " + JSON.stringify(item));
            if (item && item.length > 0) {
              this.selectedAddress = item[0];
            } else {
              this.selectedAddress = null;
            }
          },

          showGenerateMnemonicModal() {
            console.log(moment().format("HH:mm:ss") + " showGenerateMnemonicModal");
            this.$bvModal.show('modal-generatemnemonic');
          },
          showLoadPrivateKeyFromKeystoreModal() {
            console.log(moment().format("HH:mm:ss") + " showLoadPrivateKeyFromKeystoreModal");
            this.$bvModal.show('modal-loadprivatekeyfromkeystore');
          },
          showSavePrivateKeyToKeystoreModal() {
            console.log(moment().format("HH:mm:ss") + " showSavePrivateKeyToKeystoreModal");
            this.$bvModal.show('modal-saveprivatekeytokeystore');
          },

          showNewWalletFromMnemonic() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromMnemonic");
            this.$bvModal.show('modal-newwalletfrommnemonic');
          },
          showNewWalletFromPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromPrivateKey");
            this.$bvModal.show('modal-newwalletfromprivatekey');
          },
          showNewWalletFromKeystore() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromKeystore");
            this.$bvModal.show('modal-newwalletfromkeystore');
          },
          showAddressNew() {
            console.log(moment().format("HH:mm:ss") + " showAddressNew");
            this.address.mode = 'add';
            this.address.type = 'address';
            this.address.address = null;
            this.address.addressError = null;
            this.address.name = null;
            this.address.keystore = null;
            this.address.password = null;
            this.address.passwordError = null;
            this.address.privateKey = null;
            this.$bvModal.show('modal-address');
          },

          newWalletFromMnemonicGenerateRandom() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicGenerateRandom");
            try {
              const randomBytes = ethers.utils.randomBytes(this.newWalletFromMnemonic.randomBytesLength);
              this.newWalletFromMnemonic.phrase = ethers.utils.entropyToMnemonic(randomBytes);
              this.newWalletFromMnemonic.phraseError = null;

              // const randomBytes = ethers.utils.randomBytes(16);
              // const phrase = ethers.utils.entropyToMnemonic(randomBytes);
              // const node = ethers.utils.HDNode.fromMnemonic(phrase);
              // console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicGenerateRandom - node: " + JSON.stringify(node, null, 2));
              // const defaultPath = "m/44'/60'/0'/0/0";
              // const wallet = node.derivePath(defaultPath);
              // this.newWalletFromPrivateKey.privateKey = wallet.privateKey;
              // this.newWalletFromPrivateKey.privateKeyError = null;
              // this.newWalletFromPrivateKey.address = wallet.address;
              // console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicGenerateRandom - this.newWalletFromPrivateKey: " + JSON.stringify(this.newWalletFromPrivateKey, null, 2));
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicGenerateRandom ERROR: " + e.message);
            }
          },

          newWalletFromMnemonicRecompute() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicRecompute");
            if (this.newWalletFromMnemonic.phrase) {
              try {
                const node = ethers.utils.HDNode.fromMnemonic(this.newWalletFromMnemonic.phrase);
                this.newWalletFromMnemonic.phraseError = null;
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicRecompute ERROR: " + e.message);
                this.newWalletFromMnemonic.phraseError = e.message;
              }
            } else {
              this.newWalletFromMnemonic.phraseError = null;
            }
          },

          newWalletFromMnemonicAddressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAddressesRowSelected: " + JSON.stringify(item));
            if (item && item.length > 0) {
              this.newWalletFromMnemonic.selectedItem = item[0];
              this.$bvModal.show('modal-newwalletfrommnemonic-add');
            } else {
              this.newWalletFromMnemonic.selectedItem = null;
            }
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAddressesRowSelected - this.newWalletFromMnemonic: " + JSON.stringify(this.newWalletFromMnemonic, null, 2));
          },

          async newWalletFromMnemonicAdd() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAdd - this.newWalletFromMnemonic: " + JSON.stringify(this.newWalletFromMnemonic, null, 2));
            const wallet = new ethers.Wallet(this.newWalletFromMnemonic.selectedItem.privateKey);
            const encryptedText = await wallet.encrypt(this.newWalletFromMnemonic.password);
            const keystore = JSON.parse(encryptedText);
            keystore.filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.newWalletFromMnemonic.selectedItem.address.slice(2).toLowerCase();
            Vue.set(this.addresses, this.newWalletFromMnemonic.selectedItem.address, {
              type: "walletfrommnemonic",
              name: this.newWalletFromMnemonic.name,
              keystore,
            });
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAdd - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-newwalletfrommnemonic-add');
          },

          newWalletFromPrivateKeyGenerateRandom() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom");
            try {
              const randomBytes = ethers.utils.randomBytes(16);
              const phrase = ethers.utils.entropyToMnemonic(randomBytes);
              const node = ethers.utils.HDNode.fromMnemonic(phrase);
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom - node: " + JSON.stringify(node, null, 2));
              const defaultPath = "m/44'/60'/0'/0/0";
              const wallet = node.derivePath(defaultPath);
              this.newWalletFromPrivateKey.privateKey = wallet.privateKey;
              this.newWalletFromPrivateKey.privateKeyError = null;
              this.newWalletFromPrivateKey.address = wallet.address;
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom - this.newWalletFromPrivateKey: " + JSON.stringify(this.newWalletFromPrivateKey, null, 2));
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom ERROR: " + e.message);
            }
          },

          newWalletFromPrivateKeyRecompute() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyRecompute: " + JSON.stringify(this.newWalletFromPrivateKey));
            if (this.newWalletFromPrivateKey.privateKey) {
              try {
                const wallet = new ethers.Wallet(this.newWalletFromPrivateKey.privateKey);
                this.newWalletFromPrivateKey.privateKeyError = null;
                this.newWalletFromPrivateKey.address = wallet.address;
                console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyRecompute - AFTER: " + JSON.stringify(this.newWalletFromPrivateKey));
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyRecompute - privatekey ERROR: " + e.message);
                this.newWalletFromPrivateKey.privateKeyError = e.message;
                this.newWalletFromPrivateKey.address = null;
              }
            } else {
              this.newWalletFromPrivateKey.privateKeyError = null;
              this.newWalletFromPrivateKey.address = null;
            }
          },

          async newWalletFromPrivateKeyAdd() {
            const wallet = new ethers.Wallet(this.newWalletFromPrivateKey.privateKey);
            const encryptedText = await wallet.encrypt(this.newWalletFromPrivateKey.password);
            const keystore = JSON.parse(encryptedText);
            keystore.filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.newWalletFromPrivateKey.address.slice(2).toLowerCase();
            Vue.set(this.addresses, this.newWalletFromPrivateKey.address, {
              type: "walletfromprivatekey",
              name: this.newWalletFromPrivateKey.name,
              keystore,
            });
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyAdd - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-newwalletfromprivatekey');
          },

          async newWalletFromKeystoreFileChange(fileName, fileList) {
            console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreFileChange: " + JSON.stringify(fileName));
            const reader = new FileReader();
            this.newWalletFromKeystore.keystoreFileContent = {};
            const t = this;
            reader.onload = function (event) {
              const data = event.target.result;
              t.newWalletFromKeystore.keystoreFileContent = data;
              console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreFileChange - keystoreFileContent: " + t.newWalletFromKeystore.keystoreFileContent);
            };
            await reader.readAsText(fileList[0]);
          },

          async newWalletFromKeystoreLoad() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreLoad - this.newWalletFromKeystore.keystoreFileContent: " + this.newWalletFromKeystore.keystoreFileContent);
            console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreLoad - this.newWalletFromKeystore.keystoreFilePassword: " + this.newWalletFromKeystore.keystoreFilePassword);
            try {
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(this.newWalletFromKeystore.keystoreFileContent, this.newWalletFromKeystore.keystoreFilePassword);
              this.newWalletFromKeystore.privateKey = wallet.privateKey;
              this.newWalletFromKeystore.address = wallet.address;
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreLoad - keystorefile ERROR: " + e.message);
            }
          },

          async newWalletFromKeystoreAdd() {
            const wallet = new ethers.Wallet(this.newWalletFromKeystore.privateKey);
            const encryptedText = await wallet.encrypt(this.newWalletFromKeystore.password);
            const keystore = JSON.parse(encryptedText);
            keystore.filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.newWalletFromKeystore.address.slice(2).toLowerCase();
            Vue.set(this.addresses, this.newWalletFromKeystore.address, {
              type: "walletfromkeystore",
              name: this.newWalletFromKeystore.name,
              keystore,
            });
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreAdd - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-newwalletfromkeystore');
          },

          newAddressRecompute() {
            console.log(moment().format("HH:mm:ss") + " newAddressRecompute: " + JSON.stringify(this.address));
            if (this.address.address) {
              try {
                const addr = ethers.utils.getAddress(this.address.address);
                this.address.addressError = null;
                console.log(moment().format("HH:mm:ss") + " newAddressRecompute - AFTER: " + JSON.stringify(this.address));
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newAddressRecompute - ERROR: " + e.message);
                this.address.addressError = e.message;
              }
            } else {
              this.address.addressError = null;
            }
          },

          async addressAdd() {
            console.log(moment().format("HH:mm:ss") + " addressAdd - this.address: " + JSON.stringify(this.address, null, 2));
            Vue.set(this.addresses, this.address.address, {
              type: this.address.type,
              name: this.address.name,
            });
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " addressAdd - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-address');
          },

          async addressPrivateKeyPasswordUpdate() {
            try {
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(JSON.stringify(this.address.keystore), this.address.password);
              this.address.privateKey = wallet.privateKey;
              this.address.passwordError = null;
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " addressPrivateKeyPasswordUpdate - keystorefile ERROR: " + e.message);
              this.address.passwordError = e.message;
              this.address.privateKey = null;
            }
            console.log(moment().format("HH:mm:ss") + " addressPrivateKeyPasswordUpdate AFTER - this.address: " + JSON.stringify(this.address, null, 2));
          },

          async addressUpdate() {
            console.log(moment().format("HH:mm:ss") + " addressUpdate - this.address: " + JSON.stringify(this.address, null, 2));
            Vue.set(this.addresses[this.address.address], 'type', this.address.type);
            Vue.set(this.addresses[this.address.address], 'name', this.address.name);
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " addressUpdate - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-address');
          },

          async addressDelete() {
            console.log(moment().format("HH:mm:ss") + " addressDelete - this.address: " + JSON.stringify(this.address, null, 2));
            this.$bvModal.msgBoxConfirm("Delete " + this.address.address + '?')
              .then(confirmed => {
                if (confirmed) {
                  Vue.delete(this.addresses, this.address.address);
                  localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
                  console.log(moment().format("HH:mm:ss") + " addressDelete - this.addresses: " + JSON.stringify(this.addresses, null, 2));
                  this.$bvModal.hide('modal-address');
                }
              })
              .catch(err => {
              });
          },

          async signMessageSign() {
            console.log(moment().format("HH:mm:ss") + " signMessageSign - this.signMessage: " + JSON.stringify(this.signMessage, null, 2));
            const walletInfo = this.addresses[this.signMessage.wallet];
            // console.log(moment().format("HH:mm:ss") + " signMessageSign - walletInfo: " + JSON.stringify(walletInfo, null, 2));
            const wallet = new ethers.Wallet(walletInfo.privateKey);
            // console.log(moment().format("HH:mm:ss") + " signMessageSign - wallet: " + JSON.stringify(wallet, null, 2));
            const signature = await wallet.signMessage(this.signMessage.message);
            // console.log(moment().format("HH:mm:ss") + " signMessageSign - signature: " + JSON.stringify(signature, null, 2));
            Vue.set(this.signMessage, 'signature', signature);
            // let result = null;
            // try {
            //   console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress - message: " + this.signMessage.message);
            //   let pubKey = ethers.utils.recoverPublicKey(ethers.utils.arrayify(ethers.utils.hashMessage(this.signMessage.message)), signature);
            //   result = ethers.utils.computeAddress(pubKey);
            //   console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress - result: " + result);
            // } catch (e) {
            //   console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress ERROR: " + e.message);
            // }
          },

          // Older stuff below

          generateDerivedAddresses() {
            console.log(moment().format("HH:mm:ss") + " generateDerivedAddresses - this.wallet: " + JSON.stringify(this.wallet, null, 2));
            const results = [];
            if (this.wallet.type == 'mnemonic' && this.wallet.mnemonic.phrase) {
              try {
                const node = ethers.utils.HDNode.fromMnemonic(this.wallet.mnemonic.phrase, this.wallet.mnemonic.passphrase);
                for (let index = this.wallet.indexStart; index < (parseInt(this.wallet.indexStart) + this.wallet.indexCount); index++) {
                  // console.log("index: " + index);
                  let path = this.wallet.derivationPath.replace(/{index}/, index);
                  const w = node.derivePath(path);
                  results.push({
                    index,
                    path,
                    privateKey: w.privateKey,
                    address: w.address,
                    publicKey: w.publicKey,
                    compressedPublicKey: ethers.utils.computePublicKey(w.publicKey, true),
                  });
                }
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " generateDerivedAddresses ERROR: " + e.message);
                this.wallet.mnemonic.phraseError = e.message;
              }
            }
            Vue.set(this, 'generatedAddresses', results);
            // console.log(moment().format("HH:mm:ss") + " generateDerivedAddresses - this.generatedAddresses: " + JSON.stringify(this.generatedAddresses, null, 2));
          },

          generateRandomMnemonic() {
            console.log(moment().format("HH:mm:ss") + " generateRandomMnemonic - this.wallet.randomBytesLength: " + this.wallet.randomBytesLength);
            try {
              const randomBytes = ethers.utils.randomBytes(this.wallet.randomBytesLength);
              this.wallet.mnemonic.phrase = ethers.utils.entropyToMnemonic(randomBytes);
              this.wallet.mnemonic.phraseError = null;
              this.generateDerivedAddresses();
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " generateRandomMnemonic ERROR: " + e.message);
              this.wallet.mnemonic.phrase = null;
              this.wallet.mnemonic.phraseError = e.message;
              this.generatedAddresses = [];
            }
            this.$bvModal.hide('modal-generatemnemonic');
          },

          // async recomputeFromMnemonic() {
          //   console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic: " + JSON.stringify(this.wallet));
          //   if (this.wallet.tab == 0) {
          //     console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic - mnemonics: " + JSON.stringify(this.wallet));
          //     try {
          //       const wallet = new ethers.Wallet.fromMnemonic(this.wallet.mnemonic.phrase);
          //       this.wallet.mnemonic.phraseError = null;
          //       this.wallet.address = wallet.address;
          //       this.wallet.publicKey = wallet.publicKey;
          //       this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
          //     } catch (e) {
          //       console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic - mnemonics ERROR: " + e.message);
          //       this.wallet.mnemonic.phraseError = e.message;
          //       this.wallet.address = null;
          //       this.wallet.publicKey = null;
          //       this.wallet.compressedPublicKey = null;
          //     }
          //   }
          // },

          generateRandomPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey");
            try {
              const randomBytes = ethers.utils.randomBytes(16);
              // this.wallet.mnemonic.phrase = ethers.utils.entropyToMnemonic(randomBytes);
              // const node = ethers.utils.HDNode.fromMnemonic(this.wallet.mnemonic.phrase);
              const phrase = ethers.utils.entropyToMnemonic(randomBytes);
              const node = ethers.utils.HDNode.fromMnemonic(phrase);
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey - node: " + JSON.stringify(node, null, 2));
              const defaultPath = "m/44'/60'/0'/0/0";
              const wallet = node.derivePath(defaultPath);
              this.wallet.type = 'keystore';
              this.wallet.wallet = wallet;
              this.wallet.privateKey = wallet.privateKey;
              this.wallet.privateKeyError = null;
              this.wallet.address = wallet.address;
              this.wallet.publicKey = wallet.publicKey;
              this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey - this.wallet: " + JSON.stringify(this.wallet, null, 2));
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey ERROR: " + e.message);
            }
          },

          async recomputeFromPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey: " + JSON.stringify(this.wallet));
            if (this.wallet.tab == 1) {
              console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey - privatekey: " + JSON.stringify(this.wallet));
              if (this.wallet.privateKey) {
                try {
                  const wallet = new ethers.Wallet(this.wallet.privateKey);
                  this.wallet.privateKeyError = null;
                  this.wallet.address = wallet.address;
                  this.wallet.publicKey = wallet.publicKey;
                  this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
                } catch (e) {
                  console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey - privatekey ERROR: " + e.message);
                  this.wallet.privateKeyError = e.message;
                  this.wallet.address = null;
                  this.wallet.publicKey = null;
                  this.wallet.compressedPublicKey = null;
                }
              } else {
                this.wallet.privateKeyError = null;
                this.wallet.address = null;
                this.wallet.publicKey = null;
                this.wallet.compressedPublicKey = null;
              }
            }
          },

          async loadPrivateKeyFromKeystore() {
            console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore");
            try {
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - this.wallet.keystoreFileContent: " + this.wallet.keystoreFileContent);
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - this.wallet.keystoreFilePassword: " + this.wallet.keystoreFilePassword);
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(this.wallet.keystoreFileContent, this.wallet.keystoreFilePassword);
              this.wallet.type = 'keystore';
              this.wallet.wallet = wallet;
              this.wallet.privateKey = wallet.privateKey;
              this.wallet.privateKeyError = null;
              this.wallet.address = wallet.address;
              this.wallet.publicKey = wallet.publicKey;
              this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - keystorefile ERROR: " + e.message);
            }
            this.$bvModal.hide('modal-loadprivatekeyfromkeystore');
          },

          async savePrivateKeyToKeystore() {
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - this.wallet.privateKey: " + JSON.stringify(this.wallet.privateKey));
            const filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.wallet.address.slice(2).toLowerCase();
            console.log("filename: " + filename);
            const wallet = new ethers.Wallet(this.wallet.privateKey);
            const encrypted = await wallet.encrypt(this.wallet.keystoreFilePassword);
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - encrypted: " + encrypted);
            const encryptedObject = JSON.parse(encrypted);
            // const filename = encryptedObject && encryptedObject['x-ethers'] && encryptedObject['x-ethers'].gethFilename || "UTC--error-getting-filename";
            console.log("filename: " + filename);
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - JSON.stringify(JSON.parse(encrypted), null, 2): " + JSON.stringify(JSON.parse(encrypted), null, 2));
            let jsonContent = "data:text/json;charset=utf-8," + encrypted;
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - jsonContent: " + jsonContent);
            var encodedUri = encodeURI(jsonContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", filename);
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
            this.$bvModal.hide('modal-saveprivatekeytokeystore');
          },

          async keystoreFileChange(fileName, fileList) {
            console.log(moment().format("HH:mm:ss") + " keystoreFileChange: " + JSON.stringify(fileName));
            const reader = new FileReader();
            this.wallet.keystoreFileContent = {};
            const t = this;
            reader.onload = function (event) {
              const data = event.target.result;
              t.wallet.keystoreFileContent = data;
              console.log(moment().format("HH:mm:ss") + " keystoreFileContent: " + t.wallet.keystoreFileContent);
            };
            await reader.readAsText(fileList[0]);
          },

          async testIt() {
            console.log(moment().format("HH:mm:ss") + " testIt");
            const privateKey = "{myprivatekey}";
            const wallet = new ethers.Wallet(privateKey);
            const WEENUSADDRESS = "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9";
            const interface = new ethers.utils.Interface(ERC20ABI);
            const contractWithoutProvider = new ethers.Contract(WEENUSADDRESS, interface, wallet);
            const unsignedTx = await contractWithoutProvider.populateTransaction.transfer(wallet.address, 1);
            console.log("unsignedTx: " + JSON.stringify(unsignedTx, null, 2));
            console.log("address: " + wallet.address);
            const tx = {
              from: wallet.address,
              to: "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9",
              gasLimit: 50000,
              // gasPrice: 1000000,
              type: 2,
              maxFeePerGas: 1234000,
              maxPriorityFeePerGas: 1234000,
              value: 0,
              data: unsignedTx.data,
              nonce: 36,
              chainId: 11155111,
            };
            console.log("tx: " + JSON.stringify(tx));
            const signedTx = await wallet.signTransaction(tx);
            console.log("signedTx: " + signedTx);
            const decoded = ethers.utils.parseTransaction(signedTx);
            console.log("decoded: " + JSON.stringify(decoded, null, 2));
          },

          async testItOld() {
            console.log(moment().format("HH:mm:ss") + " testIt");
            const privateKey = "{myprivatekey}";
            const wallet = new ethers.Wallet(privateKey);
            console.log("address: " + wallet.address);
            const tx = {
              from: wallet.address,
              to: "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9",
              gasLimit: 50000,
              // gasPrice: 1000000,
              type: 2,
              maxFeePerGas: 1234000,
              maxPriorityFeePerGas: 1234000,
              value: 0,
              data: "",
              nonce: 35,
              chainId: 11155111,
            };
            console.log("tx: " + JSON.stringify(tx));
            // const populatedTx = await wallet.populateTransaction(tx);
            // console.log("populatedTx: " + populatedTx);
            const sig = await wallet.signTransaction(tx);
            console.log("sig: " + sig);
          },

          // async processData(provider) {
          //   console.log(moment().format("HH:mm:ss") + " processData BEGIN");
          //   const accounts = this.accounts;
          //   const events = this.events[this.chainId] || {};
          //   for (const blockNumber of Object.keys(events).sort((a, b) => { return a - b })) {
          //     const blockNumberData = events[blockNumber];
          //     for (const logIndex of Object.keys(blockNumberData).sort((a, b) => { return a - b })) {
          //       const eventData = events[blockNumber][logIndex];
          //       const contract = eventData.contract;
          //       const account = accounts[this.chainId] && accounts[this.chainId][contract] || null;
          //       // console.log(event.blockNumber + "." + event.txIndex + "." + event.logIndex + " " + JSON.stringify(event) + " " + JSON.stringify(account));
          //       if (account) {
          //         const type = account.customType || account.type;
          //         if (type == "erc20") {
          //           if (!('approvals' in account)) {
          //             account.approvals = {};
          //           }
          //           if (!(eventData.owner in account.approvals)) {
          //             account.approvals[eventData.owner] = {};
          //           }
          //           account.approvals[eventData.owner][eventData.spender] = eventData.value;
          //         } else if (type == "erc721") {
          //           if (eventData.eventName == "Approval") {
          //             if (!('approvals' in account)) {
          //               account.approvals = {};
          //             }
          //             if (!(eventData.owner in account.approvals)) {
          //               account.approvals[eventData.owner] = {};
          //             }
          //             account.approvals[eventData.owner][eventData.value] = eventData.spender;
          //           } else if (eventData.eventName == "ApprovalForAll") {
          //             if (!('approvalsForAll' in account)) {
          //               account.approvalsForAll = {};
          //             }
          //             if (!(eventData.owner in account.approvalsForAll)) {
          //               account.approvalsForAll[eventData.owner] = {};
          //             }
          //             account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
          //           }
          //         } else if (type == "erc1155") {
          //           if (!('approvalsForAll' in account)) {
          //             account.approvalsForAll = {};
          //           }
          //           if (!(eventData.owner in account.approvalsForAll)) {
          //             account.approvalsForAll[eventData.owner] = {};
          //           }
          //           account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
          //         }
          //         Vue.set(this.accounts[this.chainId], contract, account);
          //       } else {
          //         console.log(moment().format("HH:mm:ss") + " processData - account: " + contract + " not found");
          //       }
          //     }
          //   }
          //   // Get current ERC-20 allowances as these amounts are reduced by `transferFrom(...)` calls
          //   this.sync.total = 0;
          //   for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
          //     const type = accountData.customType || accountData.type;
          //     if (type == "erc20") {
          //       for (const owner of this.accountsToSearch) {
          //         const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
          //         for (const [spender, approved] of Object.entries(approvals)) {
          //           this.sync.total++;
          //         }
          //       }
          //     }
          //   }
          //   this.sync.completed = 0;
          //   this.sync.section = 'Latest ERC-20 Allowances';
          //   for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
          //     const type = accountData.customType || accountData.type;
          //     if (type == "erc20" && !this.sync.halt) {
          //       for (const owner of this.accountsToSearch) {
          //         const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
          //         for (const [spender, approved] of Object.entries(approvals)) {
          //           const erc20Contract = new ethers.Contract(account, ERC20ABI, provider);
          //           const newValue = await erc20Contract.allowance(owner, spender);
          //           accountData.approvals[owner][spender] = newValue.toString();
          //           Vue.set(this.accounts[this.chainId], account, accountData);
          //           this.sync.completed++;
          //         }
          //       }
          //     }
          //   }
          //   if (!this.sync.halt) {
          //     localStorage.approvalAccounts = JSON.stringify(accounts);
          //     Vue.set(this, 'accounts', accounts);
          //   }
          //   this.forceRefresh++; // UI refresh workaround
          //   console.log(moment().format("HH:mm:ss") + " processData END");
          // },

          saveSettings() {
            localStorage.approvalToolSettings = JSON.stringify(this.settings);
          },
          // async processNewBlock(blockNumber) {
          //   console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          // },
          // async halt() {
          //   this.sync.halt = true;
          //   console.log(moment().format("HH:mm:ss") + " halt()");
          // },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          // formatETH(e, precision = 9) {
          //   try {
          //     if (precision == 0) {
          //       return e ? ethers.utils.formatEther(e) : null;
          //     } else {
          //       return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
          //     }
          //   } catch (err) {
          //   }
          //   return e.toFixed(precision);
          // },
          // formatDecimals(e, decimals = 18) {
          //   return e ? ethers.utils.formatUnits(e, decimals) : null;
          // },
          // formatTimestamp(ts) {
          //   if (ts != null) {
          //     if (this.settings.reportingDateTime == 1) {
          //       return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
          //     } else {
          //       return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
          //     }
          //   }
          //   return null;
          // },
          // formatTimeDiff(unixtime) {
          //   if (!unixtime) {
          //     return "";
          //   } else {
          //     return moment.unix(unixtime).fromNow();
          //   }
          // },
          // nameOrAddress(address, length = 0) {
          //   let result = null;
          //   const accounts = this.accounts[this.chainId] || {};
          //   if (address in accounts) {
          //     result = accounts[address].customName || accounts[address].name || address;
          //   } else {
          //     result = address;
          //   }
          //   if (result && length > 0) {
          //     result = result.substring(0, length);
          //   }
          //   return result;
          // },
          // addressDescription(address) {
          //   const accounts = this.accounts[this.chainId] || {};
          //   if (address in accounts) {
          //     result = "address=" + address;
          //     for (let key of ['type', 'customType', 'symbol', 'name', 'customName', 'decimals', 'customDecimals', 'source']) {
          //       if (key in accounts[address] && accounts[address][key]) {
          //         result = result + "; " + key + "=" + accounts[address][key];
          //       }
          //     }
          //   } else {
          //     result = address;
          //   }
          //   return result;
          // },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          // async connectToWeb3() {
          //   if (!window.ethereum) {
          //     this.connected = false;
          //   } else {
          //     try {
          //       const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          //       this.connected = window.ethereum.isConnected();
          //     } catch (e) {
          //       console.log("window.ethereum.request error: " + e.message);
          //       this.connected = false;
          //     }
          //   }
          //   if (!this.connected) {
          //     alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
          //   } else {
          //     const t = this;
          //     function handleChainChanged(_chainId) {
          //       t.chainId = _chainId;
          //       console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
          //       alert('Ethereum chain has changed - reloading this page.')
          //       window.location.reload();
          //     }
          //     window.ethereum.on('chainChanged', handleChainChanged);
          //     const provider = new ethers.providers.Web3Provider(window.ethereum);
          //     async function handleAccountsChanged(accounts) {
          //       const signer = provider.getSigner();
          //       t.coinbase = await signer.getAddress();
          //       console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
          //     }
          //     window.ethereum.on('accountsChanged', handleAccountsChanged);
          //     async function handleNewBlock(blockNumber) {
          //       if (!t.blockNumber || blockNumber > t.blockNumber) {
          //         const block = await provider.getBlock("latest");
          //         t.blockNumber = block.number;
          //         t.timestamp = block.timestamp;
          //         await t.processNewBlock(blockNumber);
          //       }
          //     }
          //     provider.on("block", handleNewBlock);
          //     const signer = provider.getSigner();
          //     this.coinbase = await signer.getAddress();
          //     const network = await provider.getNetwork();
          //     this.chainId = network.chainId;
          //     console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
          //   }
          // },
        },

        // --- MOUNTED ---
        mounted() {
          if ('topSecretsOfflineAddresses' in localStorage) {
            this.addresses = JSON.parse(localStorage.topSecretsOfflineAddresses);
          }

          // (async() => {
          //   await this.connectToWeb3();
          // })();
          // if ('approvalToolChainId' in localStorage) {
          //   this.chainId = localStorage.approvalToolChainId;
          // }
          // if ('approvalToolCoinbase' in localStorage) {
          //   this.coinbase = localStorage.approvalToolCoinbase;
          // }
          // if ('approvalToolSettings' in localStorage) {
          //   const tempSettings = JSON.parse(localStorage.approvalToolSettings);
          //   if ('version' in tempSettings && tempSettings.version == this.settings.version) {
          //     this.settings = tempSettings;
          //     if (this.settings.approvalsTable.currentPage > 1) {
          //       this.settings.approvalsTable.currentPage = 1;
          //     }
          //   }
          // }
        },
      })
    </script>
  </body>
</html>
