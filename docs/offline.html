<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Offline:TopSecrets</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Offline:TopSecrets (c) Bok Consulting Pty Ltd 2024" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="globals.js"></script>
    <script src="customNames.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/ApprovalTool/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/topsecrets.svg" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">Offline:TopSecrets</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Wallet'">Wallet</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Wallets'">Wallets</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'ETH'">ETH</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 3; saveSettings();" :active="settings.tabIndex == 3" active-class="active" v-b-popover.hover="'ERC-20'">ERC-20</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 4; saveSettings();" :active="settings.tabIndex == 4" active-class="active" v-b-popover.hover="'ERC-721'">ERC-721</b-nav-item>
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'Accounts'">Accounts</b-nav-item> -->
            <!-- <b-avatar v-if="coinbase && coinbase != nameOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + nameOrAddress(coinbase, 100)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar> -->
            <!-- <b-button size="sm" variant="outline-primary" class="ml-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? nameOrAddress(coinbase, 16) : 'Connect' }}</b-button> -->
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert size="sm" dismissible variant="warning" show class="m-1 mb-0 my-0">
            Warning: This is experimental unaudited work-in-progress software. This dapp is meant for use on permanently offline computers.
          </b-alert>
          <b-card v-if="false" class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Mainnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <!-- :MODALGENERATEMNEMONIC -->
          <b-modal id="modal-generatemnemonic" hide-footer size="sm">
            <template #modal-title>
              Generate New Mnemonic
            </template>
            <b-form-group label="Number of words:" label-for="modal-generatemnemonic-numberofwords" label-size="sm" label-cols-sm="6" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-select size="sm" id="modal-generatemnemonic-numberofwords" v-model="wallet.randomBytesLength" :options="randomBytesLengthMnemonicWordsOptions"></b-form-select>
            </b-form-group>
            <b-form-group label="" label-for="modal-generatemnemonic-generate" label-size="sm" label-cols-sm="6" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="modal-generatemnemonic-generate" @click="generateRandomMnemonic()" variant="primary">Generate</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALLOADPRIVATEKEYFROMKEYSTORE -->
          <b-modal id="modal-loadprivatekeyfromkeystore" hide-footer size="lg">
            <template #modal-title>
              Load Private Key From JSON/UTC Keystore
            </template>
            <b-form-group label="Keystore File:" label-for="modal-loadprivatekeyfromkeystore-keystorefile" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Select encrypted keystore (JSON/UTC) file from your local computer'" class="mx-0 my-1 p-0">
              <b-form-file size="sm" id="modal-loadprivatekeyfromkeystore-keystorefile" v-model="wallet.keystoreFile" @change="keystoreFileChange($event.target.name, $event.target.files)"></b-form-file>
            </b-form-group>
            <b-form-group label="Password:" label-for="modal-loadprivatekeyfromkeystore-keystorefilepassword" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="password" autocomplete="current-password" size="sm" id="modal-loadprivatekeyfromkeystore-keystorefilepassword" v-model="wallet.keystoreFilePassword" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="modal-loadprivatekeyfromkeystore-load" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="modal-loadprivatekeyfromkeystore-load" @click="loadPrivateKeyFromKeystore()" variant="primary">Load</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALSAVEPRIVATEKEYTOKEYSTORE -->
          <b-modal id="modal-saveprivatekeytokeystore" hide-footer size="md">
            <template #modal-title>
              Save Private Key To JSON/UTC Keystore
            </template>
            <b-form-group label="Keystore File Password:" label-for="modal-saveprivatekeytokeystore-password" label-size="sm" label-cols-sm="5" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="password" autocomplete="current-password" size="sm" id="modal-saveprivatekeytokeystore-password" v-model="wallet.keystoreFilePassword"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="modal-saveprivatekeytokeystore-save" label-size="sm" label-cols-sm="5" label-align-sm="right" description="Encryption will take around half a minute" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!wallet.keystoreFilePassword" id="modal-saveprivatekeytokeystore-save" @click="savePrivateKeyToKeystore()" variant="primary">Save</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWWALLETFROMMNEMONIC -->
          <b-modal id="modal-newwalletfrommnemonic" hide-footer size="md">
            <template #modal-title>
              New Wallet From Mnemonic Seed Phrase
            </template>
          </b-modal>

          <!-- :MODALNEWWALLETFROMPRIVATEKEY -->
          <b-modal id="modal-newwalletfromprivatekey" hide-footer size="lg">
            <template #modal-title>
              New Wallet From Private Key
            </template>
            <b-form-group label="Private Key:" label-for="newwalletfromprivatekey-privatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!newWalletFromPrivateKey.privateKeyError" :invalid-feedback="newWalletFromPrivateKey.privateKeyError" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfromprivatekey-privatekey" v-model="newWalletFromPrivateKey.privateKey" @change="newWalletFromPrivateKeyRecompute();" placeholder="Type/paste your private key here or click [Generate New]" style="max-width: 600px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromprivatekey-generaterandom" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="newwalletfromprivatekey-generaterandom" @click="newWalletFromPrivateKeyGenerateRandom()" variant="primary">Generate Random</b-button>
            </b-form-group>
            <b-form-group label="ETH Address:" label-for="newwalletfromprivatekey-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfromprivatekey-address" :value="newWalletFromPrivateKey.address" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="newwalletfromprivatekey-name" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfromprivatekey-name" v-model="newWalletFromPrivateKey.name" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromprivatekey-add" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!newWalletFromPrivateKey.address" id="newwalletfromprivatekey-add" @click="newWalletFromPrivateKeyAdd()" variant="primary">Add</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWWALLETFROMKEYSTORE -->
          <b-modal id="modal-newwalletfromkeystore" hide-footer size="md">
            <template #modal-title>
              New Wallet From JSON/UTC Keystore Private Key
            </template>
          </b-modal>

          <b-card v-if="settings.tabIndex == 0" class="m-0 p-0 border-0" body-class="m-1 p-0">
            <b-form-group label-cols-lg="1" label="Wallet" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-card bg-variant="light" no-body class="p-0 m-1">
                <b-tabs card align="left" no-body v-model="wallet.tab" active-tab-class="m-0 p-0">
                  <b-tab v-for="t in tabs" :key="'dyn-tabx-' + t.name" @click="updateURL(t.name);" :title="t.text" title-item-class="p-0" title-link-class="mt-2 px-3">
                  </b-tab>
                </b-tabs>
                <b-card-text class="m-0 p-2">
                  <b-form-group v-if="wallet.tab == 0" label="Phrase:" label-for="wallet-mnemonicphrase" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.mnemonic.phraseError" :invalid-feedback="wallet.mnemonic.phraseError" class="mx-0 my-2 p-0">
                    <b-form-textarea size="sm" id="wallet-mnemonicphrase" v-model="wallet.mnemonic.phrase" @change="generateDerivedAddresses();" rows="3" placeholder="Type/paste your mnemnonic seed phrase here or click [Generate New]" style="max-width: 800px;"></b-form-textarea>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 0" label="" label-for="wallet-showgeneratemnemonicmodal" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="wallet-showgeneratemnemonicmodal" @click="showGenerateMnemonicModal()" variant="primary">Generate New</b-button>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 0" label="Passphrase:" label-for="wallet-mnemonicpassphrase" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                    <b-form-input type="text" size="sm" id="wallet-mnemonicpassphrase" v-model="wallet.mnemonic.passphrase" @change="generateDerivedAddresses();" placeholder="Optional" style="max-width: 300px;"></b-form-input>
                  </b-form-group>
                  <!-- <b-form-group v-if="wallet.tab == 0" label="Derivation Path:" label-for="wallet-derivationpath" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-form-select size="sm" id="wallet-derivationpath" v-model="wallet.derivationPath" :options="derivationPathOptions" @change="generateDerivedAddresses();" style="max-width: 300px;"></b-form-select>
                  </b-form-group> -->
                  <!-- <b-form-group v-if="wallet.tab == 0" label="Index From:" label-for="wallet-indexfrom" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-form-input type="number" size="sm" id="wallet-indexfrom" v-model="wallet.indexStart" @change="generateDerivedAddresses();" style="max-width: 100px;"></b-form-input>
                  </b-form-group> -->
                  <!-- <b-form-group v-if="wallet.tab == 0" label="Index To:" label-for="wallet-indexto" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-form-input type="number" size="sm" id="wallet-indexto" v-model="wallet.indexCount" @change="generateDerivedAddresses();" style="max-width: 100px;"></b-form-input>
                  </b-form-group> -->
                  <!-- <b-form-group v-if="false && wallet.tab == 0" label="Mnemonic Path:" label-for="wallet-mnemonicpath" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                    <b-form-input type="text" size="sm" :readonly="wallet.tab == 0 || wallet.tab == 3" id="wallet-mnemonicpath" v-model="wallet.mnemonic.path" @change="recomputeFromMnemonic();" class="w-50"></b-form-input>
                  </b-form-group> -->
                  <b-card v-if="wallet.tab == 0" class="m-0 mt-2 p-0 border-0" body-class="m-1 p-0">
                    <div class="d-flex flex-wrap m-0 p-0">
                      <div class="mt-1 pl-1">
                        <font size="-1">Derivation Path:</font>
                      </div>
                      <div class="mt-0 pl-1">
                        <b-form-select size="sm" v-model="wallet.derivationPath" :options="derivationPathOptions" @change="generateDerivedAddresses();" style="max-width: 300px;" v-b-popover.hover.bottom="'Derivation Path'"></b-form-select>
                      </div>
                      <div class="mt-0 flex-grow-1">
                      </div>
                      <div class="mt-1 pr-1">
                        <font size="-1">Start:</font>
                      </div>
                      <div class="mt-0 pr-1">
                        <b-form-input type="number" size="sm" v-model="wallet.indexStart" min="0" @change="generateDerivedAddresses();" style="max-width: 100px;" v-b-popover.hover.bottom="'Index Start'"></b-form-input>
                      </div>
                      <!-- <div class="mt-1 pr-1">
                        <font size="-1">Count:</font>
                      </div> -->
                      <div class="mt-0">
                        <!-- <b-form-input type="number" size="sm" v-model="wallet.indexCount" @change="generateDerivedAddresses();" style="max-width: 100px;" v-b-popover.hover.bottom="'Index To'"></b-form-input> -->
                        <b-form-select size="sm" v-model="wallet.indexCount" :options="indexCountOptions" @change="generateDerivedAddresses();"></b-form-select>
                      </div>
                    </div>
                    <!-- <b-table v-if="settings.tabIndex == 0 && !settings.showInfo" ref="approvalsTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='approvalsRowSelected' :fields="approvalsFields" :items="pagedFilteredSortedApprovals" show-empty empty-html="Click Sync above to retrieve ERC-20, ERC-721 and ERC-1155 approval events" head-variant="light" class="mx-0 my-1"> -->
                    <b-table ref="addressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='addressesRowSelected':fields="addressesFields" :items="addresses" show-empty empty-html="Enter information above" head-variant="light" class="mx-0 my-1">
                      <template #cell(index)="data">
                        <font size="-1">
                          {{ data.item.index }}
                        </font>
                      </template>
                      <template #cell(path)="data">
                        <font size="-1">
                          {{ data.item.path }}
                        </font>
                      </template>
                      <template #cell(address)="data">
                        <font size="-1">
                          {{ data.item.address }}
                        </font>
                      </template>
                      <template #cell(privateKey)="data">
                        <font size="-1">
                          {{ data.item.privateKey }}
                        </font>
                      </template>
                    </b-table>
                  </b-card>
                  <b-form-group v-if="wallet.tab == 1" label="Private Key:" label-for="wallet-privatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!wallet.privateKeyError" :invalid-feedback="wallet.privateKeyError" class="mx-0 my-2 p-0">
                    <b-form-input type="text" size="sm" id="wallet-privatekey" v-model="wallet.privateKey" @change="recomputeFromPrivateKey();" placeholder="Type/paste your private key here, click [Generate New] or [Load From Keystore]" class="w-75"></b-form-input>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 1" label="" label-for="wallet-generaterandomprivatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="wallet-generaterandomprivatekey" @click="generateRandomPrivateKey()" variant="primary">Generate New</b-button>
                    <b-button size="sm" @click="showLoadPrivateKeyFromKeystoreModal()" variant="primary">Load From Keystore</b-button>
                    <b-button size="sm" :disabled="!wallet.privateKey || !!wallet.privateKeyError" @click="showSavePrivateKeyToKeystoreModal()" variant="primary">Save To Keystore</b-button>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 1" label="ETH Address:" label-for="output-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-3 p-0">
                    <b-form-input type="text" size="sm" readonly id="output-address" :value="wallet.address" class="w-50"></b-form-input>
                  </b-form-group>
                  <b-form-group v-if="false && wallet.tab == 0" label="Debug Addresses:" label-for="debug-addresses-textarea" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 mt-3 p-0">
                    <b-form-textarea size="sm" readonly id="debug-addresses-textarea" :value="JSON.stringify(addresses, null, 2)" rows="3" max-rows="10" class="w-100"></b-form-textarea>
                  </b-form-group>
                  <b-form-group v-if="false" label="Debug:" label-for="debug-textarea" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 mt-3 p-0">
                    <b-form-textarea size="sm" readonly id="debug-textarea" :value="JSON.stringify(wallet, null, 2)" rows="3" max-rows="10" class="w-100"></b-form-textarea>
                  </b-form-group>
                  <b-form-group v-if="false" label="Test:" label-for="wallet-testit" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="wallet-testit" @click="testIt()" variant="warning">Test</b-button>
                  </b-form-group>
                </b-card-text>
              </b-card>
            </b-form-group>
          </b-card>

          <!-- :WALLETS -->
          <b-card v-if="settings.tabIndex == 1" class="m-0 p-0 border-0" body-class="m-1 p-0">

            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-dropdown size="sm" variant="link" v-b-popover.hover.bottom="'New Wallet'">
                  <template #button-content>
                    <b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus>
                  </template>
                  <b-dropdown-item @click="showNewWalletFromMnemonic">New Wallet From Mnemonic</b-dropdown-item>
                  <b-dropdown-item @click="showNewWalletFromPrivateKey">New Wallet From Private Key</b-dropdown-item>
                  <b-dropdown-item @click="showNewWalletFromKeystore">New Wallet From JSON/UTC Keystore Private Key</b-dropdown-item>
                </b-dropdown>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pl-1">
                <font size="-2" v-b-popover.hover.bottom="'# wallets'">{{ commify0(wallets.length) }}</font>
              </div>
              <div class="mt-0 pl-1">
                <b-pagination size="sm" v-model="settings.walletsTable.currentPage" @input="saveSettings" :total-rows="filteredSortedWallets.length" :per-page="settings.walletsTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <!-- <b-form-select size="sm" v-model="settings.walletsTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select> -->
                <b-form-select size="sm" v-model="settings.walletsTable.pageSize" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
              </div>
            </div>
            <!-- <b-table small fixed striped responsive hover :fields="accountsFields" :items="pagedFilteredSortedAccounts" show-empty empty-html="Click Sync above to retrieve ERC-20, ERC-721 and ERC-1155 approval events" head-variant="light" class="mx-0 my-1"> -->
            <b-table small fixed striped responsive hover :fields="walletsFields" :items="pagedFilteredSortedWallets" show-empty empty-html="Add new wallets" head-variant="light" class="mx-0 my-1">
              <template #cell(number)="data">
                <font size="-1">
                  {{ parseInt(data.index) + ((settings.walletsTable.currentPage - 1) * settings.walletsTable.pageSize) + 1 }}
                </font>
              </template>
              <!-- <template #cell(address)="data">
                <b-link :href="'https://etherscan.io/address/' + data.item.address" target="_blank">
                  <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.address)" class="px-0">{{ data.item.address.substring(0, 6) + '...' + data.item.address.substring(38) }}</b-badge>
                </b-link>
              </template> -->
              <!-- <template #cell(source)="data">
                <b-badge pill variant="transparent" v-b-popover.hover="'Owner, contract or spender from approvals'" class="px-0">{{ data.item.source.substring(0, 1).toUpperCase() + data.item.source.substring(1) }}</b-badge>
              </template> -->
              <!-- <template #cell(type)="data">
                <b-badge pill variant="transparent" v-b-popover.hover="'Detected account type'" class="px-0">{{ accountTypeOptions.filter(e => e.value == data.item.type)[0].text }}</b-badge>
              </template> -->
              <!-- <template #cell(customType)="data">
                <b-form-select size="sm" v-model="data.item.customType" @change="customTypeUpdated(data.item.address, $event)" :options="accountTypeOptions" v-b-popover.hover.bottom="'Override detected type'"></b-form-select>
              </template> -->
              <!-- <template #cell(symbol)="data">
                <b-badge pill variant="transparent" v-b-popover.hover="'Symbol for ERC-20, ERC-721 and ERC-1155: ' + data.item.symbol " class="px-0">{{ data.item.symbol }}</b-badge>
              </template> -->
              <!-- <template #cell(name)="data">
                <b-badge pill variant="transparent" v-b-popover.hover="'Name: ' + data.item.name" class="px-0">{{ data.item.name }}</b-badge>
              </template> -->
              <!-- <template #cell(customName)="data">
                <b-form-input size="sm" v-model="data.item.customName" @change="customNameUpdated(data.item.address, $event)" placeholder="Custom name" v-b-popover.hover.bottom="'Override detected name'"></b-form-input>
              </template> -->
              <!-- <template #cell(decimals)="data">
                <b-badge pill variant="transparent" v-b-popover.hover="'Detected decimals'" class="px-0">{{ data.item.decimals }}</b-badge>
              </template> -->
              <!-- <template #cell(customDecimals)="data">
                <span v-if="(data.item.customType == null && data.item.type == 'erc20') || data.item.customType == 'erc20'">
                  <b-form-select size="sm" v-model="data.item.customDecimals" @change="customDecimalsUpdated(data.item.address, $event)" :options="decimalsOptions" v-b-popover.hover.bottom="'Override detected decimals'"></b-form-select>
                </span>
              </template> -->
            </b-table>

          </b-card>

          <!-- :ETH -->
          <b-card v-if="settings.tabIndex == 2" class="m-0 p-0 border-0" body-class="m-1 p-0">
            TODO: Send ETH tx, with data field
            <b-form-group label="Test:" label-for="wallet-testit" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="wallet-testit" @click="testIt()" variant="warning">Test</b-button>
            </b-form-group>
          </b-card>

          <!-- :ERC20 -->
          <b-card v-if="settings.tabIndex == 3" class="m-0 p-0 border-0" body-class="m-1 p-0">
            TODO: ERC-20 Functions - approve, transfer, transferFrom
          </b-card>

          <!-- :ERC721 -->
          <b-card v-if="settings.tabIndex == 4" class="m-0 p-0 border-0" body-class="m-1 p-0">
            TODO: ERC-721 Functions - *approv*, *transfer*
          </b-card>

        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="false && connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>Offline:TopSecrets</i> &copy; Bok Consulting Pty Ltd 2024
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          wallet: {
            tab: 0, // 0: 'mnemonic', 1: 'privatekey'

            type: 'mnemonic', // 'mnemonic', 'privatekey'
            wallet: null, // HDNode for type 'mnemonic', Wallet for type 'privatekey'

            mnemonic: {
              phrase: null,
              phraseError: null,
              passphrase: null,
              path: "m/44'/60'/0'/0/0", // null,
              locale: null,
            },

            derivationPath: "m/44'/60'/0'/0/{index}",
            indexStart: 0,
            indexCount: 10,

            keystoreFile: null,
            keystoreFilePassword: null,
            keystoreFileContent: null,

            privateKey: null,
            privateKeyError: null,

            randomBytesLength: 16, // 12 words

            publicKey: null,
            compressedPublicKey: null,
            address: null,

            hiddenUsername: null, // For HTML accessibility
          },

          newWalletFromMnemonic: {
          },

          newWalletFromPrivateKey: {
            privateKey: null,
            privateKeyError: null,
            address: null,
            name: null,
          },

          newWalletFromKeystore: {
          },

          addresses: [],
          selectedAddress: null,

          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,
          forceRefresh: 0,

          settings: {
            tabIndex: 1,
            walletsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'addressasc',
            },
            version: 12,
          },
          wallets: {},
          // sync: {
          //   section: null,
          //   total: null,
          //   completed: null,
          //   halt: false,
          // },

          tabs: [
            { name: 'mnemonic', text: 'Mnemonic Seed Phrase' },
            { name: 'privatekey', text: 'Private Key' },
          ],

          walletTypeOptions: [
            { value: 'mnemonic', text: 'Mnemonic Seed Phrase' },
            { value: 'keystorefile', text: 'JSON/UTC Keystore File' },
            { value: 'privatekey', text: 'Private Key' },
          ],

          randomBytesLengthMnemonicWordsOptions: [
            { value: 16, text: '12 Words' },
            { value: 20, text: '15 Words' },
            { value: 24, text: '18 Words' },
            { value: 28, text: '21 Words' },
            { value: 32, text: '24 Words' },
          ],

          // MM HW Paths
          // Ledger Live
          // Legacy (MEW/MyCrypto)
          // BIP44 Standard (e.g. MetaMask, Trezor)
          derivationPathOptions: [
            { value: "m/44'/60'/0'/0/{index}", text: "BIP-44 m/44'/60'/0'/0/{index}" },
            { value: "m/44'/60'/0'/0/{index}", text: "Legacy (MEW/MyCrypto) m/44'/60'/0'/0/{index}" }, // TODO: Check difference in MM settings with Ledger
            { value: "m/44'/60'/0'/{index}/0", text: "Test-1 m/44'/60'/0'/{index}/0" },
            { value: "m/44'/60'/0'/0/{index}/0", text: "Test-2 m/44'/60'/0'/0/{index}/0" },
          ],

          indexCountOptions: [
            { value: 1, text: '1' },
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
          ],

          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],

          addressesFields: [
            { key: 'index', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'path', label: 'Path', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'privateKey', label: 'Private Key', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-left' },
          ],

          walletsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'source', label: 'Source', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-left' },
            // { key: 'customType', label: '', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-left' },
            // { key: 'symbol', label: 'Symbol', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'customName', label: '', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            // { key: 'decimals', label: 'Decimals', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
            // { key: 'customDecimals', label: '', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
          ],

        },

        // --- COMPUTED ---
        computed: {

          filteredWallets() {
            console.log(moment().format("HH:mm:ss") + " filteredWallets: " + JSON.stringify(this.wallets));
            // let results = this.forceRefresh % 2 == 0 ? [] : [];
            const results = [];
            for (const [address, data] of Object.entries(this.wallets)) {
              results.push({
                address,
                type: data.type,
                privateKey: data.privateKey,
                name: data.name,
              });
            }
            return results;
          },
          filteredSortedWallets() {
            let results = this.filteredWallets;
          //   if (this.settings.accountsTable.sortOption == 'typenameasc') {
          //     results.sort((a, b) => {
          //       const typeA = a.customType || a.type;
          //       const typeB = b.customType || b.type;
          //       const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
          //       const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
          //       if (sortIndexA == sortIndexB) {
          //         const namea = a.customName || a.name;
          //         const nameb = b.customName || b.name;
          //         return ('' + namea).localeCompare(nameb);
          //       } else {
          //         return sortIndexA - sortIndexB;
          //       }
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'typenamedsc') {
          //     results.sort((a, b) => {
          //       const typeA = a.customType || a.type;
          //       const typeB = b.customType || b.type;
          //       const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
          //       const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
          //       if (sortIndexA == sortIndexB) {
          //         const namea = a.customName || a.name;
          //         const nameb = b.customName || b.name;
          //         return ('' + nameb).localeCompare(namea);
          //       } else {
          //         return sortIndexB - sortIndexA;
          //       }
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'nameasc') {
          //     results.sort((a, b) => {
          //       return ('' + a.name).localeCompare(b.name);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'namedsc') {
          //     results.sort((a, b) => {
          //       return ('' + b.name).localeCompare(a.name);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'addressasc') {
          //     results.sort((a, b) => {
          //       return ('' + a.address).localeCompare(b.address);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'addressdsc') {
          //     results.sort((a, b) => {
          //       return ('' + b.address).localeCompare(a.address);
          //     });
          //   }
            return results;
          },
          pagedFilteredSortedWallets() {
            console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedWallets - results[0..9]: " + JSON.stringify(this.filteredSortedWallets.slice(0, 10), null, 2));
            return this.filteredSortedWallets.slice((this.settings.walletsTable.currentPage - 1) * this.settings.walletsTable.pageSize, this.settings.walletsTable.currentPage * this.settings.walletsTable.pageSize);
          },

          accountsToSearch() {
            return this.settings.searchAttachedAccount ? [ this.coinbase ] : (this.settings.searchAccounts && this.settings.searchAccounts.split(/[, \t\n]+/).filter(name => name.match(/0x[0-9a-fA-F]{40}/)) || []);
          },
        },

        // --- METHODS ---
        methods: {

          updateURL(where) {
            console.log(moment().format("HH:mm:ss") + " TODO updateURL: " + where);
          },

          addressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " addressesRowSelected: " + JSON.stringify(item));
            if (item && item.length > 0) {
              this.selectedAddress = item[0];
            } else {
              this.selectedAddress = null;
            }
          },

          showGenerateMnemonicModal() {
            console.log(moment().format("HH:mm:ss") + " showGenerateMnemonicModal");
            this.$bvModal.show('modal-generatemnemonic');
          },
          showLoadPrivateKeyFromKeystoreModal() {
            console.log(moment().format("HH:mm:ss") + " showLoadPrivateKeyFromKeystoreModal");
            this.$bvModal.show('modal-loadprivatekeyfromkeystore');
          },
          showSavePrivateKeyToKeystoreModal() {
            console.log(moment().format("HH:mm:ss") + " showSavePrivateKeyToKeystoreModal");
            this.$bvModal.show('modal-saveprivatekeytokeystore');
          },

          showNewWalletFromMnemonic() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromMnemonic");
            this.$bvModal.show('modal-newwalletfrommnemonic');
          },
          showNewWalletFromPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromPrivateKey");
            this.$bvModal.show('modal-newwalletfromprivatekey');
          },
          showNewWalletFromKeystore() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromKeystore");
            this.$bvModal.show('modal-newwalletfromkeystore');
          },

          newWalletFromPrivateKeyGenerateRandom() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom");
            try {
              const randomBytes = ethers.utils.randomBytes(16);
              const phrase = ethers.utils.entropyToMnemonic(randomBytes);
              const node = ethers.utils.HDNode.fromMnemonic(phrase);
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom - node: " + JSON.stringify(node, null, 2));
              const defaultPath = "m/44'/60'/0'/0/0";
              const wallet = node.derivePath(defaultPath);
              this.newWalletFromPrivateKey.privateKey = wallet.privateKey;
              this.newWalletFromPrivateKey.privateKeyError = null;
              this.newWalletFromPrivateKey.address = wallet.address;
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom - this.newWalletFromPrivateKey: " + JSON.stringify(this.newWalletFromPrivateKey, null, 2));
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom ERROR: " + e.message);
            }
          },

          newWalletFromPrivateKeyRecompute() {
            console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey: " + JSON.stringify(this.newWalletFromPrivateKey));
            if (this.newWalletFromPrivateKey.privateKey) {
              try {
                const wallet = new ethers.Wallet(this.newWalletFromPrivateKey.privateKey);
                this.newWalletFromPrivateKey.privateKeyError = null;
                this.newWalletFromPrivateKey.address = wallet.address;
                console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey - AFTER: " + JSON.stringify(this.newWalletFromPrivateKey));
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey - privatekey ERROR: " + e.message);
                this.newWalletFromPrivateKey.privateKeyError = e.message;
                this.newWalletFromPrivateKey.address = null;
              }
            } else {
              this.newWalletFromPrivateKey.privateKeyError = null;
              this.newWalletFromPrivateKey.address = null;
            }
          },

          newWalletFromPrivateKeyAdd() {
            Vue.set(this.wallets, this.newWalletFromPrivateKey.address, {
              type: "privatekey",
              name: this.newWalletFromPrivateKey.name,
              privateKey: this.newWalletFromPrivateKey.privateKey,
            });
            localStorage.topSecretsOfflineWallets = JSON.stringify(this.wallets);
            console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyAdd - this.wallets: " + JSON.stringify(this.wallets, null, 2));
            this.$bvModal.hide('modal-newwalletfromprivatekey');
          },

          generateDerivedAddresses() {
            console.log(moment().format("HH:mm:ss") + " generateDerivedAddresses");
            const results = [];
            if (this.wallet.type == 'mnemonic' && this.wallet.mnemonic.phrase) {
              try {
                const node = ethers.utils.HDNode.fromMnemonic(this.wallet.mnemonic.phrase, this.wallet.mnemonic.passphrase);
                for (let index = this.wallet.indexStart; index < (parseInt(this.wallet.indexStart) + this.wallet.indexCount); index++) {
                  let path = this.wallet.derivationPath.replace(/{index}/, index);
                  const w = node.derivePath(path);
                  results.push({
                    index,
                    path,
                    privateKey: w.privateKey,
                    address: w.address,
                    publicKey: w.publicKey,
                    compressedPublicKey: ethers.utils.computePublicKey(w.publicKey, true),
                  });
                }
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " generateDerivedAddresses ERROR: " + e.message);
                this.wallet.mnemonic.phraseError = e.message;
              }
            }
            this.addresses = results;
          },

          generateRandomMnemonic() {
            console.log(moment().format("HH:mm:ss") + " generateRandomMnemonic - this.wallet.randomBytesLength: " + this.wallet.randomBytesLength);
            try {
              const randomBytes = ethers.utils.randomBytes(this.wallet.randomBytesLength);
              this.wallet.mnemonic.phrase = ethers.utils.entropyToMnemonic(randomBytes);
              this.wallet.mnemonic.phraseError = null;
              this.generateDerivedAddresses();
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " generateRandomMnemonic ERROR: " + e.message);
              this.wallet.mnemonic.phrase = null;
              this.wallet.mnemonic.phraseError = e.message;
              this.addresses = [];
            }
            this.$bvModal.hide('modal-generatemnemonic');
          },

          // async recomputeFromMnemonic() {
          //   console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic: " + JSON.stringify(this.wallet));
          //   if (this.wallet.tab == 0) {
          //     console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic - mnemonics: " + JSON.stringify(this.wallet));
          //     try {
          //       const wallet = new ethers.Wallet.fromMnemonic(this.wallet.mnemonic.phrase);
          //       this.wallet.mnemonic.phraseError = null;
          //       this.wallet.address = wallet.address;
          //       this.wallet.publicKey = wallet.publicKey;
          //       this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
          //     } catch (e) {
          //       console.log(moment().format("HH:mm:ss") + " recomputeFromMnemonic - mnemonics ERROR: " + e.message);
          //       this.wallet.mnemonic.phraseError = e.message;
          //       this.wallet.address = null;
          //       this.wallet.publicKey = null;
          //       this.wallet.compressedPublicKey = null;
          //     }
          //   }
          // },

          generateRandomPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey");
            try {
              const randomBytes = ethers.utils.randomBytes(16);
              // this.wallet.mnemonic.phrase = ethers.utils.entropyToMnemonic(randomBytes);
              // const node = ethers.utils.HDNode.fromMnemonic(this.wallet.mnemonic.phrase);
              const phrase = ethers.utils.entropyToMnemonic(randomBytes);
              const node = ethers.utils.HDNode.fromMnemonic(phrase);
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey - node: " + JSON.stringify(node, null, 2));
              const defaultPath = "m/44'/60'/0'/0/0";
              const wallet = node.derivePath(defaultPath);

              this.wallet.type = 'keystore';
              this.wallet.wallet = wallet;

              this.wallet.privateKey = wallet.privateKey;
              this.wallet.privateKeyError = null;

              this.wallet.address = wallet.address;
              this.wallet.publicKey = wallet.publicKey;
              this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey - this.wallet: " + JSON.stringify(this.wallet, null, 2));
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " generateRandomPrivateKey ERROR: " + e.message);
            }
          },

          async recomputeFromPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey: " + JSON.stringify(this.wallet));
            if (this.wallet.tab == 1) {
              console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey - privatekey: " + JSON.stringify(this.wallet));
              if (this.wallet.privateKey) {
                try {
                  const wallet = new ethers.Wallet(this.wallet.privateKey);
                  this.wallet.privateKeyError = null;
                  this.wallet.address = wallet.address;
                  this.wallet.publicKey = wallet.publicKey;
                  this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
                } catch (e) {
                  console.log(moment().format("HH:mm:ss") + " recomputeFromPrivateKey - privatekey ERROR: " + e.message);
                  this.wallet.privateKeyError = e.message;
                  this.wallet.address = null;
                  this.wallet.publicKey = null;
                  this.wallet.compressedPublicKey = null;
                }
              } else {
                this.wallet.privateKeyError = null;
                this.wallet.address = null;
                this.wallet.publicKey = null;
                this.wallet.compressedPublicKey = null;
              }
            }
          },

          async loadPrivateKeyFromKeystore() {
            console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore");
            try {
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - this.wallet.keystoreFileContent: " + this.wallet.keystoreFileContent);
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - this.wallet.keystoreFilePassword: " + this.wallet.keystoreFilePassword);
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(this.wallet.keystoreFileContent, this.wallet.keystoreFilePassword);

              this.wallet.type = 'keystore';
              this.wallet.wallet = wallet;

              this.wallet.privateKey = wallet.privateKey;
              this.wallet.privateKeyError = null;
              this.wallet.address = wallet.address;
              this.wallet.publicKey = wallet.publicKey;
              this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " loadPrivateKeyFromKeystore - keystorefile ERROR: " + e.message);
            }
            this.$bvModal.hide('modal-loadprivatekeyfromkeystore');
          },

          async savePrivateKeyToKeystore() {
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - this.wallet.privateKey: " + JSON.stringify(this.wallet.privateKey));

            const filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.wallet.address.slice(2).toLowerCase();
            console.log("filename: " + filename);

            const wallet = new ethers.Wallet(this.wallet.privateKey);
            const encrypted = await wallet.encrypt(this.wallet.keystoreFilePassword);
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - encrypted: " + encrypted);
            const encryptedObject = JSON.parse(encrypted);
            // const filename = encryptedObject && encryptedObject['x-ethers'] && encryptedObject['x-ethers'].gethFilename || "UTC--error-getting-filename";
            console.log("filename: " + filename);
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - JSON.stringify(JSON.parse(encrypted), null, 2): " + JSON.stringify(JSON.parse(encrypted), null, 2));
            let jsonContent = "data:text/json;charset=utf-8," + encrypted;
            console.log(moment().format("HH:mm:ss") + " savePrivateKeyToKeystore - jsonContent: " + jsonContent);
            var encodedUri = encodeURI(jsonContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", filename);
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
            this.$bvModal.hide('modal-saveprivatekeytokeystore');
          },

          async keystoreFileChange(fileName, fileList) {
            console.log(moment().format("HH:mm:ss") + " keystoreFileChange: " + JSON.stringify(fileName));
            const reader = new FileReader();
            this.wallet.keystoreFileContent = {};
            const t = this;
            reader.onload = function (event) {
              const data = event.target.result;
              t.wallet.keystoreFileContent = data;
              console.log(moment().format("HH:mm:ss") + " keystoreFileContent: " + t.wallet.keystoreFileContent);
            };
            await reader.readAsText(fileList[0]);
          },

          async testIt() {
            console.log(moment().format("HH:mm:ss") + " testIt");
          },


          // async processData(provider) {
          //   console.log(moment().format("HH:mm:ss") + " processData BEGIN");
          //   const accounts = this.accounts;
          //   const events = this.events[this.chainId] || {};
          //   for (const blockNumber of Object.keys(events).sort((a, b) => { return a - b })) {
          //     const blockNumberData = events[blockNumber];
          //     for (const logIndex of Object.keys(blockNumberData).sort((a, b) => { return a - b })) {
          //       const eventData = events[blockNumber][logIndex];
          //       const contract = eventData.contract;
          //       const account = accounts[this.chainId] && accounts[this.chainId][contract] || null;
          //       // console.log(event.blockNumber + "." + event.txIndex + "." + event.logIndex + " " + JSON.stringify(event) + " " + JSON.stringify(account));
          //       if (account) {
          //         const type = account.customType || account.type;
          //         if (type == "erc20") {
          //           if (!('approvals' in account)) {
          //             account.approvals = {};
          //           }
          //           if (!(eventData.owner in account.approvals)) {
          //             account.approvals[eventData.owner] = {};
          //           }
          //           account.approvals[eventData.owner][eventData.spender] = eventData.value;
          //         } else if (type == "erc721") {
          //           if (eventData.eventName == "Approval") {
          //             if (!('approvals' in account)) {
          //               account.approvals = {};
          //             }
          //             if (!(eventData.owner in account.approvals)) {
          //               account.approvals[eventData.owner] = {};
          //             }
          //             account.approvals[eventData.owner][eventData.value] = eventData.spender;
          //           } else if (eventData.eventName == "ApprovalForAll") {
          //             if (!('approvalsForAll' in account)) {
          //               account.approvalsForAll = {};
          //             }
          //             if (!(eventData.owner in account.approvalsForAll)) {
          //               account.approvalsForAll[eventData.owner] = {};
          //             }
          //             account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
          //           }
          //         } else if (type == "erc1155") {
          //           if (!('approvalsForAll' in account)) {
          //             account.approvalsForAll = {};
          //           }
          //           if (!(eventData.owner in account.approvalsForAll)) {
          //             account.approvalsForAll[eventData.owner] = {};
          //           }
          //           account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
          //         }
          //         Vue.set(this.accounts[this.chainId], contract, account);
          //       } else {
          //         console.log(moment().format("HH:mm:ss") + " processData - account: " + contract + " not found");
          //       }
          //     }
          //   }
          //   // Get current ERC-20 allowances as these amounts are reduced by `transferFrom(...)` calls
          //   this.sync.total = 0;
          //   for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
          //     const type = accountData.customType || accountData.type;
          //     if (type == "erc20") {
          //       for (const owner of this.accountsToSearch) {
          //         const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
          //         for (const [spender, approved] of Object.entries(approvals)) {
          //           this.sync.total++;
          //         }
          //       }
          //     }
          //   }
          //   this.sync.completed = 0;
          //   this.sync.section = 'Latest ERC-20 Allowances';
          //   for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
          //     const type = accountData.customType || accountData.type;
          //     if (type == "erc20" && !this.sync.halt) {
          //       for (const owner of this.accountsToSearch) {
          //         const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
          //         for (const [spender, approved] of Object.entries(approvals)) {
          //           const erc20Contract = new ethers.Contract(account, ERC20ABI, provider);
          //           const newValue = await erc20Contract.allowance(owner, spender);
          //           accountData.approvals[owner][spender] = newValue.toString();
          //           Vue.set(this.accounts[this.chainId], account, accountData);
          //           this.sync.completed++;
          //         }
          //       }
          //     }
          //   }
          //   if (!this.sync.halt) {
          //     localStorage.approvalAccounts = JSON.stringify(accounts);
          //     Vue.set(this, 'accounts', accounts);
          //   }
          //   this.forceRefresh++; // UI refresh workaround
          //   console.log(moment().format("HH:mm:ss") + " processData END");
          // },

          saveSettings() {
            localStorage.approvalToolSettings = JSON.stringify(this.settings);
          },
          // async processNewBlock(blockNumber) {
          //   console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          // },
          // async halt() {
          //   this.sync.halt = true;
          //   console.log(moment().format("HH:mm:ss") + " halt()");
          // },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          // formatETH(e, precision = 9) {
          //   try {
          //     if (precision == 0) {
          //       return e ? ethers.utils.formatEther(e) : null;
          //     } else {
          //       return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
          //     }
          //   } catch (err) {
          //   }
          //   return e.toFixed(precision);
          // },
          // formatDecimals(e, decimals = 18) {
          //   return e ? ethers.utils.formatUnits(e, decimals) : null;
          // },
          // formatTimestamp(ts) {
          //   if (ts != null) {
          //     if (this.settings.reportingDateTime == 1) {
          //       return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
          //     } else {
          //       return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
          //     }
          //   }
          //   return null;
          // },
          // formatTimeDiff(unixtime) {
          //   if (!unixtime) {
          //     return "";
          //   } else {
          //     return moment.unix(unixtime).fromNow();
          //   }
          // },
          // nameOrAddress(address, length = 0) {
          //   let result = null;
          //   const accounts = this.accounts[this.chainId] || {};
          //   if (address in accounts) {
          //     result = accounts[address].customName || accounts[address].name || address;
          //   } else {
          //     result = address;
          //   }
          //   if (result && length > 0) {
          //     result = result.substring(0, length);
          //   }
          //   return result;
          // },
          // addressDescription(address) {
          //   const accounts = this.accounts[this.chainId] || {};
          //   if (address in accounts) {
          //     result = "address=" + address;
          //     for (let key of ['type', 'customType', 'symbol', 'name', 'customName', 'decimals', 'customDecimals', 'source']) {
          //       if (key in accounts[address] && accounts[address][key]) {
          //         result = result + "; " + key + "=" + accounts[address][key];
          //       }
          //     }
          //   } else {
          //     result = address;
          //   }
          //   return result;
          // },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          // async connectToWeb3() {
          //   if (!window.ethereum) {
          //     this.connected = false;
          //   } else {
          //     try {
          //       const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          //       this.connected = window.ethereum.isConnected();
          //     } catch (e) {
          //       console.log("window.ethereum.request error: " + e.message);
          //       this.connected = false;
          //     }
          //   }
          //   if (!this.connected) {
          //     alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
          //   } else {
          //     const t = this;
          //     function handleChainChanged(_chainId) {
          //       t.chainId = _chainId;
          //       console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
          //       alert('Ethereum chain has changed - reloading this page.')
          //       window.location.reload();
          //     }
          //     window.ethereum.on('chainChanged', handleChainChanged);
          //     const provider = new ethers.providers.Web3Provider(window.ethereum);
          //     async function handleAccountsChanged(accounts) {
          //       const signer = provider.getSigner();
          //       t.coinbase = await signer.getAddress();
          //       console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
          //     }
          //     window.ethereum.on('accountsChanged', handleAccountsChanged);
          //     async function handleNewBlock(blockNumber) {
          //       if (!t.blockNumber || blockNumber > t.blockNumber) {
          //         const block = await provider.getBlock("latest");
          //         t.blockNumber = block.number;
          //         t.timestamp = block.timestamp;
          //         await t.processNewBlock(blockNumber);
          //       }
          //     }
          //     provider.on("block", handleNewBlock);
          //     const signer = provider.getSigner();
          //     this.coinbase = await signer.getAddress();
          //     const network = await provider.getNetwork();
          //     this.chainId = network.chainId;
          //     console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
          //   }
          // },
        },

        // --- MOUNTED ---
        mounted() {
          if ('topSecretsOfflineWallets' in localStorage) {
            this.wallets = JSON.parse(localStorage.topSecretsOfflineWallets);
          }

          // (async() => {
          //   await this.connectToWeb3();
          // })();
          // if ('approvalToolChainId' in localStorage) {
          //   this.chainId = localStorage.approvalToolChainId;
          // }
          // if ('approvalToolCoinbase' in localStorage) {
          //   this.coinbase = localStorage.approvalToolCoinbase;
          // }
          // if ('approvalToolSettings' in localStorage) {
          //   const tempSettings = JSON.parse(localStorage.approvalToolSettings);
          //   if ('version' in tempSettings && tempSettings.version == this.settings.version) {
          //     this.settings = tempSettings;
          //     if (this.settings.approvalsTable.currentPage > 1) {
          //       this.settings.approvalsTable.currentPage = 1;
          //     }
          //   }
          // }
        },
      })
    </script>
  </body>
</html>
