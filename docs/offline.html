<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Offline: TopSecrets</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="TopSecrets - Offline (c) Bok Consulting Pty Ltd 2024" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="globals.js"></script>
    <script src="customNames.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/ApprovalTool/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/topsecrets.svg" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">TopSecrets - Offline</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Approvals'">Approvals</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Events'">Events</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'Accounts'">Accounts</b-nav-item> -->
            <!-- <b-avatar v-if="coinbase && coinbase != nameOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + nameOrAddress(coinbase, 100)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar> -->
            <!-- <b-button size="sm" variant="outline-primary" class="ml-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? nameOrAddress(coinbase, 16) : 'Connect' }}</b-button> -->
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert size="sm" dismissible variant="warning" show class="m-1 mb-0 my-0">
            Warning: This is experimental unaudited work-in-progress software. This dapp is meant for use on permanently offline computers.
          </b-alert>
          <b-card v-if="false" class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Mainnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <b-card class="m-0 p-0 border-0" body-class="m-1 p-0">

            <b-form-group label-cols-lg="1" label="Wallet" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">

              <b-card bg-variant="light" no-body class="p-0 m-1">
                <b-tabs card align="left" no-body v-model="wallet.tab" active-tab-class="m-0 p-0">
                  <b-tab v-for="t in tabs" :key="'dyn-tabx-' + t.name" @click="updateURL(t.name);" :title="t.text" title-item-class="p-0" title-link-class="mt-2 px-2">
                  </b-tab>
                </b-tabs>
                <b-card-text class="m-0 p-2">

                  <b-form-group v-if="wallet.tab == 3" label="New Wallet:" label-for="wallet-new" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="wallet-new" @click="newWallet()" variant="warning">Generate</b-button>
                  </b-form-group>

                  <b-form-group v-if="wallet.tab == 0 || wallet.tab == 3" label="Mnemonic Seed Phrase:" label-for="wallet-mnemonicphrase" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                    <b-form-textarea size="sm" :readonly="wallet.tab == 3" id="wallet-mnemonicphrase" v-model="wallet.mnemonic.phrase" @change="recomputeWallet();" rows="3" class="w-100"></b-form-textarea>
                  </b-form-group>

                  <b-form-group v-if="wallet.tab == 0 || wallet.tab == 3" label="Mnemonic Path:" label-for="wallet-mnemonicpath" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                    <b-form-input type="text" size="sm" :readonly="wallet.tab == 0 || wallet.tab == 3" id="wallet-mnemonicpath" v-model="wallet.mnemonic.path" @change="recomputeWallet();" class="w-75"></b-form-input>
                  </b-form-group>

                  <b-form-group v-if="wallet.tab == 1" label="Keystore File:" label-for="wallet-keystorefile" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Select encrypted keystore (JSON/UTC) file from your local computer'" class="mx-0 my-1 p-0">
                    <b-form-file size="sm" id="wallet-keystorefile" v-model="wallet.keystoreFile" @change="keystoreFileChange($event.target.name, $event.target.files)" class="w-75"></b-form-file>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 1" label="Keystore File Password:" label-for="wallet-keystorefilepassword" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-form-input type="password" autocomplete="current-password" size="sm" id="wallet-keystorefilepassword" v-model="wallet.keystoreFilePassword" @change="recomputeWallet();" class="w-25"></b-form-input>
                  </b-form-group>

                  <b-form-group v-if="wallet.tab == 2 || wallet.tab == 3" label="Private Key:" label-for="wallet-privatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-form-input type="text" :readonly="wallet.tab == 3" size="sm" id="wallet-privatekey" v-model="wallet.privateKey" @change="recomputeWallet();" class="w-75"></b-form-input>
                  </b-form-group>

                  <b-form-group label="ETH Address:" label-for="output-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-form-input type="text" size="sm" readonly id="output-address" :value="wallet.address" class="w-50"></b-form-input>
                  </b-form-group>

                  <b-form-group v-if="wallet.tab == 3" label="Password:" label-for="keystore-password" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-form-input type="password" autocomplete="current-password" size="sm" id="keystore-password" v-model="wallet.keystoreFilePassword" @change="recomputeWallet();" class="w-25"></b-form-input>
                  </b-form-group>
                  <b-form-group v-if="wallet.tab == 3" label="JSON/UTC Keystore:" label-for="wallet-download" label-size="sm" label-cols-sm="2" label-align-sm="right" description="This will take around half a minute" class="mx-0 my-1 p-0">
                    <b-button size="sm" :disabled="!wallet.keystoreFilePassword || !wallet.privateKey" id="wallet-download" @click="downloadKeystore()" variant="warning">Download</b-button>
                  </b-form-group>

                  <b-form-group v-if="false" label="Debug:" label-for="debug-textarea" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                    <b-form-textarea size="sm" readonly id="debug-textarea" :value="JSON.stringify(wallet, null, 2)" rows="3" max-rows="10" class="w-100"></b-form-textarea>
                  </b-form-group>

                </b-card-text>
              </b-card>

            </b-form-group>



            <b-card-text v-if="false" class="m-0 p-0">
              <!-- :WALLET -->
              <b-card no-body class="my-0 p-1">
                <b-card-body class="mt-1 p-1">
                  <b-form>
                    <b-form-group label-cols-lg="1" label="Wallet" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                      <b-form-group label="Type:" label-for="wallet-type" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-select size="sm" id="wallet-type" v-model="wallet.type" @change="recomputeWallet();" :options="walletTypeOptions" class="w-25"></b-form-select>
                      </b-form-group>

                      <b-form-group v-if="wallet.type == 'privatekey'" label="Private Key:" label-for="wallet-privatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="wallet-privatekey" v-model="wallet.privateKey" @change="recomputeWallet();" class="w-75"></b-form-input>
                      </b-form-group>

                      <b-form-group v-if="wallet.type == 'mnemonic'" label="Mnemonics:" label-for="wallet-mnemonics" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-textarea size="sm" id="wallet-mnemonics" v-model="wallet.mnemonics" @change="recomputeWallet();" rows="3" class="w-75"></b-form-textarea>
                      </b-form-group>
                      <b-form-group v-if="wallet.type == 'mnemonic'" label="Path:" label-for="wallet-mnemonicspath" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-textarea size="sm" id="wallet-mnemonicspath" v-model="wallet.mnemonic.path" @change="recomputeWallet();" rows="3" class="w-75"></b-form-textarea>
                      </b-form-group>

                      <b-form-group v-if="wallet.type == 'keystorefile'" label="Keystore File:" label-for="wallet-keystorefile" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Select encrypted keystore (JSON/UTC) file from your local computer'" class="mx-0 my-1 p-0">
                        <b-form-file size="sm" id="wallet-keystorefile" v-model="wallet.keystoreFile" @change="keystoreFileChange($event.target.name, $event.target.files)" class="w-75"></b-form-file>
                      </b-form-group>
                      <b-form-group v-if="wallet.type == 'keystorefile'" label="Keystore File Password:" label-for="wallet-keystorefilepassword" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="password" autocomplete="current-password" size="sm" id="wallet-keystorefilepassword" v-model="wallet.keystoreFilePassword" @change="recomputeWallet();" class="w-25"></b-form-input>
                      </b-form-group>
                      <!-- <b-form-input type="text" size="sm" id="wallet-username" v-model="wallet.hiddenUsername" style="display: none;"></b-form-input> -->

                      <b-form-group v-if="false" label="Test:" label-for="wallet-testit" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-button size="sm" id="wallet-testit" @click="testIt()" variant="warning">Test</b-button>
                      </b-form-group>
                    </b-form-group>

                    <b-form-group label-cols-lg="1" label="Output" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                      <b-form-group label="Public Key:" label-for="output-publickey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-textarea size="sm" readonly id="output-publickey" :value="wallet.publicKey" rows="3" class="w-75"></b-form-textarea>
                      </b-form-group>
                      <b-form-group label="Compressed Public Key:" label-for="output-compressedpublickey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" readonly id="output-compressedpublickey" :value="wallet.compressedPublicKey" class="w-75"></b-form-input>
                      </b-form-group>
                      <b-form-group label="ETH Address:" label-for="output-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" readonly id="output-address" :value="wallet.address" class="w-50"></b-form-input>
                      </b-form-group>
                    </b-form-group>

                    <b-form-group v-if="false" label-cols-lg="1" label="Debug" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                      <b-form-group label="Type:" label-for="debug-textarea" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-textarea size="sm" readonly id="debug-textarea" :value="JSON.stringify(wallet, null, 2)" rows="3" max-rows="10" class="w-100"></b-form-textarea>
                      </b-form-group>
                    </b-form-group>

                  </b-form>

                </b-card-body>
              </b-card>

            </b-card-text>
          </b-card>
        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="false && connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>TopSecrets - Offline</i> &copy; Bok Consulting Pty Ltd 2024
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          wallet: {
            tab: 3, // 0: 'mnemonic', 1: 'keystorefile', 2: 'privatekey', 3: 'new'
            type: 'mnemonic', // 'mnemonic', 'keystorefile', 'privatekey'
            mnemonic: {
              phrase: null,
              path: "m/44'/60'/0'/0/0", // null,
              locale: null,
            },
            keystoreFile: null,
            keystoreFilePassword: null,
            keystoreFileContent: null,
            privateKey: null,
            newWallet: null,

            publicKey: null,
            compressedPublicKey: null,
            address: null,

            hiddenUsername: null, // For HTML accessibility
          },

          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,
          forceRefresh: 0,

          settings: {
            tabIndex: 0,
            version: 12,
          },
          // sync: {
          //   section: null,
          //   total: null,
          //   completed: null,
          //   halt: false,
          // },

          tabs: [
            { name: 'mnemonic', text: 'Mnemonic Seed Phrase' },
            { name: 'keystorefile', text: 'JSON/UTC Keystore File' },
            { name: 'privatekey', text: 'Private Key' },
            { name: 'new', text: 'New Wallet' },
          ],

          walletTypeOptions: [
            { value: 'mnemonic', text: 'Mnemonic Seed Phrase' },
            { value: 'keystorefile', text: 'JSON/UTC Keystore File' },
            { value: 'privatekey', text: 'Private Key' },
          ],

        },

        // --- COMPUTED ---
        computed: {
          accountsToSearch() {
            return this.settings.searchAttachedAccount ? [ this.coinbase ] : (this.settings.searchAccounts && this.settings.searchAccounts.split(/[, \t\n]+/).filter(name => name.match(/0x[0-9a-fA-F]{40}/)) || []);
          },
        },

        // --- METHODS ---
        methods: {

          updateURL(where) {
            console.log(moment().format("HH:mm:ss") + " TODO updateURL: " + where);
          },

          newWallet() {
            console.log(moment().format("HH:mm:ss") + " newWallet");
            try {
              const wallet = new ethers.Wallet.createRandom();
              console.table(wallet);
              this.wallet.address = wallet.address;
              this.wallet.privateKey = wallet.privateKey;
              console.log("wallet.privateKey: " + wallet.privateKey);
              console.log("wallet.mnemonic: " + JSON.stringify(wallet.mnemonic));
              this.wallet.mnemonic.phrase = wallet.mnemonic.phrase;
              this.wallet.mnemonic.path = wallet.mnemonic.path;
              this.wallet.mnemonic.locale = wallet.mnemonic.locale;
              this.wallet.newWallet = wallet;
              // this.wallet.publicKey = wallet.publicKey;
              // this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " newWallet ERROR: " + e.message);
            }
          },

          async downloadKeystore() {
            console.log(moment().format("HH:mm:ss") + " downloadKeystore - this.wallet.newWallet: " + JSON.stringify(this.wallet.newWallet));
            const encrypted = await this.wallet.newWallet.encrypt(this.wallet.keystoreFilePassword);
            console.log(moment().format("HH:mm:ss") + " downloadKeystore - encrypted: " + encrypted);
            const encryptedObject = JSON.parse(encrypted);
            const filename = encryptedObject && encryptedObject['x-ethers'] && encryptedObject['x-ethers'].gethFilename || "UTC--error-getting-filename";
            console.log("filename: " + filename);
            console.log(moment().format("HH:mm:ss") + " downloadKeystore - JSON.stringify(JSON.parse(encrypted), null, 2): " + JSON.stringify(JSON.parse(encrypted), null, 2));
            let jsonContent = "data:text/json;charset=utf-8," + encrypted;
            console.log(moment().format("HH:mm:ss") + " downloadKeystore - jsonContent: " + jsonContent);
            var encodedUri = encodeURI(jsonContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", filename);
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
          },

          async recomputeWallet() {
            console.log(moment().format("HH:mm:ss") + " recomputeWallet: " + JSON.stringify(this.wallet));
            if (this.wallet.tab == 0) {
              console.log(moment().format("HH:mm:ss") + " recomputeWallet - mnemonics: " + JSON.stringify(this.wallet));
              try {
                const wallet = new ethers.Wallet.fromMnemonic(this.wallet.mnemonic.phrase);
                this.wallet.address = wallet.address;
                this.wallet.publicKey = wallet.publicKey;
                this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " recomputeWallet - mnemonics ERROR: " + e.message);
              }

            } else if (this.wallet.tab == 1) {
              console.log(moment().format("HH:mm:ss") + " recomputeWallet - keystorefile: " + JSON.stringify(this.wallet));
              try {
                console.log(moment().format("HH:mm:ss") + " recomputeWallet - this.wallet.keystoreFileContent: " + this.wallet.keystoreFileContent);
                console.log(moment().format("HH:mm:ss") + " recomputeWallet - this.wallet.keystoreFilePassword: " + this.wallet.keystoreFilePassword);
                const wallet = await ethers.Wallet.fromEncryptedJsonSync(this.wallet.keystoreFileContent, this.wallet.keystoreFilePassword);
                this.wallet.address = wallet.address;
                this.wallet.publicKey = wallet.publicKey;
                this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " recomputeWallet - keystorefile ERROR: " + e.message);
              }
            } else if (this.wallet.tab == 2){
              console.log(moment().format("HH:mm:ss") + " recomputeWallet - privatekey: " + JSON.stringify(this.wallet));
              try {
                const wallet = new ethers.Wallet(this.wallet.privateKey);
                this.wallet.address = wallet.address;
                this.wallet.publicKey = wallet.publicKey;
                this.wallet.compressedPublicKey = ethers.utils.computePublicKey(wallet.publicKey, true);
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " recomputeWallet - privatekey ERROR: " + e.message);
              }
            }
          },

          async keystoreFileChange(fileName, fileList) {
            console.log(moment().format("HH:mm:ss") + " keystoreFileChange: " + JSON.stringify(fileName));
            const reader = new FileReader();
            this.wallet.keystoreFileContent = {};
            const t = this;
            reader.onload = function (event) {
              const data = event.target.result;
              t.wallet.keystoreFileContent = data;
              console.log(moment().format("HH:mm:ss") + " keystoreFileContent: " + t.wallet.keystoreFileContent);
            };
            await reader.readAsText(fileList[0]);
          },

          async testIt() {
            console.log(moment().format("HH:mm:ss") + " testIt");
            const jsonText = '{"version":3,"id":"e14b94f9-cabc-445c-9b8a-ea090540d8db","address":"62325d923da56ab815367aa591c0a10cff1d0ddd","crypto":{"ciphertext":"4f19f96b36100b1b54d95f4106e38949cd56967dcba919d814ab962fed3b688b","cipherparams":{"iv":"befb0e2386402c71e06dd3d2cca4f828"},"cipher":"aes-128-ctr","kdf":"scrypt","kdfparams":{"dklen":32,"salt":"67d0ff891bbbbe29eb98828bae566f5a31c131ff05f207b22f4ff2bcc7643bc6","n":8192,"r":8,"p":1},"mac":"7092eb22b1d4c58ff07ff913555fe2ca5a36040f51c4edfbccf1ddfb49216f70"}}';
            const password = '';
            const json = JSON.parse(jsonText);
            console.log("json: " + JSON.stringify(json, null, 2));
            console.log("password: " + password);
            try {
              console.log(moment().format("HH:mm:ss") + " Start");
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(jsonText, password);
              console.log(moment().format("HH:mm:ss") + " End");
              console.log(JSON.stringify(wallet, null, 2));
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " testIt ERROR: " + e.message);
            }
          },


          // async processData(provider) {
          //   console.log(moment().format("HH:mm:ss") + " processData BEGIN");
          //   const accounts = this.accounts;
          //   const events = this.events[this.chainId] || {};
          //   for (const blockNumber of Object.keys(events).sort((a, b) => { return a - b })) {
          //     const blockNumberData = events[blockNumber];
          //     for (const logIndex of Object.keys(blockNumberData).sort((a, b) => { return a - b })) {
          //       const eventData = events[blockNumber][logIndex];
          //       const contract = eventData.contract;
          //       const account = accounts[this.chainId] && accounts[this.chainId][contract] || null;
          //       // console.log(event.blockNumber + "." + event.txIndex + "." + event.logIndex + " " + JSON.stringify(event) + " " + JSON.stringify(account));
          //       if (account) {
          //         const type = account.customType || account.type;
          //         if (type == "erc20") {
          //           if (!('approvals' in account)) {
          //             account.approvals = {};
          //           }
          //           if (!(eventData.owner in account.approvals)) {
          //             account.approvals[eventData.owner] = {};
          //           }
          //           account.approvals[eventData.owner][eventData.spender] = eventData.value;
          //         } else if (type == "erc721") {
          //           if (eventData.eventName == "Approval") {
          //             if (!('approvals' in account)) {
          //               account.approvals = {};
          //             }
          //             if (!(eventData.owner in account.approvals)) {
          //               account.approvals[eventData.owner] = {};
          //             }
          //             account.approvals[eventData.owner][eventData.value] = eventData.spender;
          //           } else if (eventData.eventName == "ApprovalForAll") {
          //             if (!('approvalsForAll' in account)) {
          //               account.approvalsForAll = {};
          //             }
          //             if (!(eventData.owner in account.approvalsForAll)) {
          //               account.approvalsForAll[eventData.owner] = {};
          //             }
          //             account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
          //           }
          //         } else if (type == "erc1155") {
          //           if (!('approvalsForAll' in account)) {
          //             account.approvalsForAll = {};
          //           }
          //           if (!(eventData.owner in account.approvalsForAll)) {
          //             account.approvalsForAll[eventData.owner] = {};
          //           }
          //           account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
          //         }
          //         Vue.set(this.accounts[this.chainId], contract, account);
          //       } else {
          //         console.log(moment().format("HH:mm:ss") + " processData - account: " + contract + " not found");
          //       }
          //     }
          //   }
          //   // Get current ERC-20 allowances as these amounts are reduced by `transferFrom(...)` calls
          //   this.sync.total = 0;
          //   for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
          //     const type = accountData.customType || accountData.type;
          //     if (type == "erc20") {
          //       for (const owner of this.accountsToSearch) {
          //         const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
          //         for (const [spender, approved] of Object.entries(approvals)) {
          //           this.sync.total++;
          //         }
          //       }
          //     }
          //   }
          //   this.sync.completed = 0;
          //   this.sync.section = 'Latest ERC-20 Allowances';
          //   for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
          //     const type = accountData.customType || accountData.type;
          //     if (type == "erc20" && !this.sync.halt) {
          //       for (const owner of this.accountsToSearch) {
          //         const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
          //         for (const [spender, approved] of Object.entries(approvals)) {
          //           const erc20Contract = new ethers.Contract(account, ERC20ABI, provider);
          //           const newValue = await erc20Contract.allowance(owner, spender);
          //           accountData.approvals[owner][spender] = newValue.toString();
          //           Vue.set(this.accounts[this.chainId], account, accountData);
          //           this.sync.completed++;
          //         }
          //       }
          //     }
          //   }
          //   if (!this.sync.halt) {
          //     localStorage.approvalAccounts = JSON.stringify(accounts);
          //     Vue.set(this, 'accounts', accounts);
          //   }
          //   this.forceRefresh++; // UI refresh workaround
          //   console.log(moment().format("HH:mm:ss") + " processData END");
          // },

          // customTypeUpdated(address, type) {
          //   Vue.set(this.accounts[this.chainId][address], 'customType', type);
          //   localStorage.approvalAccounts = JSON.stringify(this.accounts);
          // },
          // customNameUpdated(address, name) {
          //   Vue.set(this.accounts[this.chainId][address], 'customName', name);
          //   localStorage.approvalAccounts = JSON.stringify(this.accounts);
          // },
          // customDecimalsUpdated(address, decimals) {
          //   Vue.set(this.accounts[this.chainId][address], 'customDecimals', decimals);
          //   localStorage.approvalAccounts = JSON.stringify(this.accounts);
          // },

          saveSettings() {
            localStorage.approvalToolSettings = JSON.stringify(this.settings);
          },
          // async processNewBlock(blockNumber) {
          //   console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          // },
          // async halt() {
          //   this.sync.halt = true;
          //   console.log(moment().format("HH:mm:ss") + " halt()");
          // },
          // commify0(n) {
          //   if (n != null) {
          //     return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
          //   }
          //   return null;
          // },
          // formatETH(e, precision = 9) {
          //   try {
          //     if (precision == 0) {
          //       return e ? ethers.utils.formatEther(e) : null;
          //     } else {
          //       return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
          //     }
          //   } catch (err) {
          //   }
          //   return e.toFixed(precision);
          // },
          // formatDecimals(e, decimals = 18) {
          //   return e ? ethers.utils.formatUnits(e, decimals) : null;
          // },
          // formatTimestamp(ts) {
          //   if (ts != null) {
          //     if (this.settings.reportingDateTime == 1) {
          //       return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
          //     } else {
          //       return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
          //     }
          //   }
          //   return null;
          // },
          // formatTimeDiff(unixtime) {
          //   if (!unixtime) {
          //     return "";
          //   } else {
          //     return moment.unix(unixtime).fromNow();
          //   }
          // },
          // nameOrAddress(address, length = 0) {
          //   let result = null;
          //   const accounts = this.accounts[this.chainId] || {};
          //   if (address in accounts) {
          //     result = accounts[address].customName || accounts[address].name || address;
          //   } else {
          //     result = address;
          //   }
          //   if (result && length > 0) {
          //     result = result.substring(0, length);
          //   }
          //   return result;
          // },
          // addressDescription(address) {
          //   const accounts = this.accounts[this.chainId] || {};
          //   if (address in accounts) {
          //     result = "address=" + address;
          //     for (let key of ['type', 'customType', 'symbol', 'name', 'customName', 'decimals', 'customDecimals', 'source']) {
          //       if (key in accounts[address] && accounts[address][key]) {
          //         result = result + "; " + key + "=" + accounts[address][key];
          //       }
          //     }
          //   } else {
          //     result = address;
          //   }
          //   return result;
          // },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          // async connectToWeb3() {
          //   if (!window.ethereum) {
          //     this.connected = false;
          //   } else {
          //     try {
          //       const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          //       this.connected = window.ethereum.isConnected();
          //     } catch (e) {
          //       console.log("window.ethereum.request error: " + e.message);
          //       this.connected = false;
          //     }
          //   }
          //   if (!this.connected) {
          //     alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
          //   } else {
          //     const t = this;
          //     function handleChainChanged(_chainId) {
          //       t.chainId = _chainId;
          //       console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
          //       alert('Ethereum chain has changed - reloading this page.')
          //       window.location.reload();
          //     }
          //     window.ethereum.on('chainChanged', handleChainChanged);
          //     const provider = new ethers.providers.Web3Provider(window.ethereum);
          //     async function handleAccountsChanged(accounts) {
          //       const signer = provider.getSigner();
          //       t.coinbase = await signer.getAddress();
          //       console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
          //     }
          //     window.ethereum.on('accountsChanged', handleAccountsChanged);
          //     async function handleNewBlock(blockNumber) {
          //       if (!t.blockNumber || blockNumber > t.blockNumber) {
          //         const block = await provider.getBlock("latest");
          //         t.blockNumber = block.number;
          //         t.timestamp = block.timestamp;
          //         await t.processNewBlock(blockNumber);
          //       }
          //     }
          //     provider.on("block", handleNewBlock);
          //     const signer = provider.getSigner();
          //     this.coinbase = await signer.getAddress();
          //     const network = await provider.getNetwork();
          //     this.chainId = network.chainId;
          //     console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
          //   }
          // },
        },

        // --- MOUNTED ---
        mounted() {
          // (async() => {
          //   await this.connectToWeb3();
          // })();
          // if ('approvalToolChainId' in localStorage) {
          //   this.chainId = localStorage.approvalToolChainId;
          // }
          // if ('approvalToolCoinbase' in localStorage) {
          //   this.coinbase = localStorage.approvalToolCoinbase;
          // }
          // if ('approvalToolSettings' in localStorage) {
          //   const tempSettings = JSON.parse(localStorage.approvalToolSettings);
          //   if ('version' in tempSettings && tempSettings.version == this.settings.version) {
          //     this.settings = tempSettings;
          //     if (this.settings.approvalsTable.currentPage > 1) {
          //       this.settings.approvalsTable.currentPage = 1;
          //     }
          //     if (this.settings.eventsTable.currentPage > 1) {
          //       this.settings.eventsTable.currentPage = 1;
          //     }
          //     if (this.settings.accountsTable.currentPage > 1) {
          //       this.settings.accountsTable.currentPage = 1;
          //     }
          //     // Restore other settings for the same version
          //     if ('approvalEvents' in localStorage) {
          //       this.events = JSON.parse(localStorage.approvalEvents);
          //     }
          //     if ('approvalAccounts' in localStorage) {
          //       this.accounts = JSON.parse(localStorage.approvalAccounts);
          //     }
          //     if ('approvalBlockTimestamps' in localStorage) {
          //       this.blockTimestamps = JSON.parse(localStorage.approvalBlockTimestamps);
          //     }
          //   }
          // }
        },
      })
    </script>
  </body>
</html>
