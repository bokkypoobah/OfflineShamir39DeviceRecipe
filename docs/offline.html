<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Offline:TopSecrets</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Offline:TopSecrets (c) Bok Consulting Pty Ltd 2024" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="globals.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/ApprovalTool/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/topsecrets.svg" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">Offline:TopSecrets</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Addresses, including your wallets, public ETH addresses, token contracts, ...'">Addresses</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Craft Ether transactions'">ETH</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'ERC-20'">ERC-20</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 3; saveSettings();" :active="settings.tabIndex == 3" active-class="active" v-b-popover.hover="'ERC-721'">ERC-721</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 4; saveSettings();" :active="settings.tabIndex == 4" active-class="active" v-b-popover.hover="'Sign and check messages'">Messages</b-nav-item>
            <!-- <b-avatar v-if="coinbase && coinbase != nameOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + nameOrAddress(coinbase, 100)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar> -->
            <!-- <b-button size="sm" variant="outline-primary" class="ml-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? nameOrAddress(coinbase, 16) : 'Connect' }}</b-button> -->
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert size="sm" dismissible variant="warning" show class="m-1 mb-0 my-0">
            Warning: This is experimental unaudited work-in-progress software. This dapp is meant for use on permanently offline computers.
          </b-alert>
          <b-card v-if="false" class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Mainnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <!-- :MODALNEWWALLETFROMMNEMONIC -->
          <b-modal id="modal-newwalletfrommnemonic" hide-footer size="lg">
            <template #modal-title>
              New Wallet From Mnemonic Seed Phrase
            </template>
            <b-form-group label="Phrase:" label-for="newwalletfrommnemonic-mnemonicphrase" label-size="sm" label-cols-sm="3" label-align-sm="right" :state="!newWalletFromMnemonic.phraseError" :invalid-feedback="newWalletFromMnemonic.phraseError" class="mx-0 my-2 p-0">
              <b-form-textarea size="sm" id="newwalletfrommnemonic-mnemonicphrase" v-model.trim="newWalletFromMnemonic.phrase" @change="newWalletFromMnemonicRecompute();" debounce="600" rows="3" placeholder="Type/paste your mnemnonic seed phrase here or click [Generate Random]" style="max-width: 800px;"></b-form-textarea>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfrommnemonic-generaterandom" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group style="max-width: 300px;">
                <b-form-select size="sm" v-model="newWalletFromMnemonic.randomBytesLength" :options="randomBytesLengthMnemonicWordsOptions"></b-form-select>
                <b-input-group-append>
                  <b-button size="sm" id="newwalletfrommnemonic-generaterandom" @click="newWalletFromMnemonicGenerateRandom()" variant="primary">Generate Random</b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="Passphrase:" label-for="newwalletfrommnemonic-passphrase" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-2 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-0 pl-1">
                  <b-form-input type="password" size="sm" id="newwalletfrommnemonic-passphrase" v-model.trim="newWalletFromMnemonic.passphrase" placeholder="Optional" debounce="600" style="max-width: 300px;"></b-form-input>
                </div>
                <div class="mt-0 pl-1">
                  <b-form-input type="password" size="sm" id="newwalletfrommnemonic-confirmpassphrase" v-model.trim="newWalletFromMnemonic.confirmPassphrase" placeholder="Confirm" debounce="600" style="max-width: 300px;"></b-form-input>
                </div>
              </div>
            </b-form-group>
            <b-form-group label="Derivation Path:" label-for="newwalletfrommnemonic-derivationpath" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-2 p-0">
              <b-form-select size="sm" id="newwalletfrommnemonic-derivationpath" v-model.trim="newWalletFromMnemonic.derivationPath" :options="derivationPathOptions" style="max-width: 300px;" v-b-popover.hover.bottom="'Derivation Path'"></b-form-select>
            </b-form-group>
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-form-spinbutton size="sm" v-model="newWalletFromMnemonic.page" min="0" inline v-b-popover.hover.bottom="'Page'"></b-form-spinbutton>
              </div>
              <div class="mt-0">
                <b-form-select size="sm" v-model="newWalletFromMnemonic.pageSize" :options="indexPageSizeOptions" v-b-popover.hover.bottom="'Page Size'"></b-form-select>
              </div>
            </div>
            <font size="-1">
              <b-table ref="newWalletFromMnemonicAddressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='newWalletFromMnemonicAddressesRowSelected' :fields="newWalletFromMnemonicAddressesFields" :items="newWalletFromMnemonicAddresses" show-empty empty-html="Enter information above" head-variant="light" class="mx-0 my-1">
                <template #cell(index)="data">
                  {{ data.item.index }}
                </template>
                <template #cell(path)="data">
                  {{ data.item.path }}
                </template>
                <template #cell(address)="data">
                  {{ data.item.address }}
                </template>
              </b-table>
            </font>
          </b-modal>

          <!-- :MODALNEWWALLETFROMMNEMONICADD -->
          <b-modal id="modal-newwalletfrommnemonic-add" hide-footer size="lg">
            <template #modal-title>
              Add New Wallet From Mnemonic Seed Phrase
            </template>
            <b-form-group v-if="newWalletFromMnemonic.selectedItem" label="Path:" label-for="newwalletfrommnemonic-add-path" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfrommnemonic-add-path" :value="newWalletFromMnemonic.selectedItem.path" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="newWalletFromMnemonic.selectedItem" label="Address:" label-for="newwalletfrommnemonic-add-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfrommnemonic-add-address" :value="newWalletFromMnemonic.selectedItem.address" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="newWalletFromMnemonic.selectedItem" label="Private Key:" label-for="newwalletfrommnemonic-add-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfrommnemonic-add-privatekey" v-model="newWalletFromMnemonic.selectedItem.privateKey" style="max-width: 600px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="newwalletfrommnemonic-add-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfrommnemonic-add-name" v-model.trim="newWalletFromMnemonic.name" debounce="600" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfrommnemonic-password" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-0 pr-1">
                  <b-form-input type="password" size="sm" id="newwalletfrommnemonic-password" v-model.trim="newWalletFromMnemonic.password" placeholder="Password" style="max-width: 300px;"></b-form-input>
                </div>
                <div class="mt-0 pr-1">
                  <b-form-input type="password" size="sm" id="newwalletfrommnemonic-confirmpassword" v-model.trim="newWalletFromMnemonic.confirmPassword" placeholder="Confirm password" style="max-width: 300px;"></b-form-input>
                </div>
                <div class="mt-0 pr-1">
                  <b-button size="sm" :disabled="newWalletFromMnemonic.adding || !newWalletFromMnemonic.selectedItem || !newWalletFromMnemonic.selectedItem.address || !newWalletFromMnemonic.password || (newWalletFromMnemonic.password != newWalletFromMnemonic.confirmPassword)" id="newwalletfrommnemonic-add-add" @click="newWalletFromMnemonicAdd()" variant="primary">{{ newWalletFromMnemonic.adding ? "Adding " : "Add" }}<b-spinner v-if="newWalletFromMnemonic.adding" small variant="light" label="Spinning"></b-spinner></b-button>
                </div>
              </div>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWWALLETFROMPRIVATEKEY -->
          <b-modal id="modal-newwalletfromprivatekey" hide-footer size="lg">
            <template #modal-title>
              New Wallet From Private Key
            </template>
            <b-form-group label="Private Key:" label-for="newwalletfromprivatekey-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" :state="!newWalletFromPrivateKey.privateKeyError" :invalid-feedback="newWalletFromPrivateKey.privateKeyError" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfromprivatekey-privatekey" v-model.trim="newWalletFromPrivateKey.privateKey" @change="newWalletFromPrivateKeyRecompute();" placeholder="Type/paste your private key here or click [Generate New]" style="max-width: 600px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromprivatekey-generaterandom" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="newwalletfromprivatekey-generaterandom" @click="newWalletFromPrivateKeyGenerateRandom()" variant="primary">Generate Random</b-button>
            </b-form-group>
            <b-form-group label="Address:" label-for="newwalletfromprivatekey-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfromprivatekey-address" :value="newWalletFromPrivateKey.address" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="newwalletfromprivatekey-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfromprivatekey-name" v-model.trim="newWalletFromPrivateKey.name" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromprivatekey-password" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-0 pr-1">
                  <b-form-input type="password" size="sm" id="newwalletfromprivatekey-password" v-model.trim="newWalletFromPrivateKey.password" placeholder="Password" style="max-width: 300px;"></b-form-input>
                </div>
                <div class="mt-0 pr-1">
                  <b-form-input type="password" size="sm" id="newwalletfromprivatekey-confirmpassword" v-model.trim="newWalletFromPrivateKey.confirmPassword" placeholder="Confirm password" style="max-width: 300px;"></b-form-input>
                </div>
                <div class="mt-0 pr-1">
                  <b-button size="sm" :disabled="newWalletFromPrivateKey.adding || !newWalletFromPrivateKey.address || !newWalletFromPrivateKey.password || (newWalletFromPrivateKey.password != newWalletFromPrivateKey.confirmPassword)" id="newwalletfromprivatekey-add" @click="newWalletFromPrivateKeyAdd()" variant="primary">{{ newWalletFromPrivateKey.adding ? "Adding " : "Add" }}<b-spinner v-if="newWalletFromPrivateKey.adding" small variant="light" label="Spinning"></b-spinner></b-button>
                </div>
              </div>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWWALLETFROMKEYSTORE -->
          <b-modal id="modal-newwalletfromkeystore" hide-footer size="lg">
            <template #modal-title>
              New Wallet From JSON/UTC Keystore Private Key
            </template>
            <b-form-group label="Keystore File:" label-for="newwalletfromkeystore-keystorefile" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="'Select encrypted keystore (JSON/UTC) file from your local computer'" class="mx-0 my-1 p-0">
              <b-form-file size="sm" id="newwalletfromkeystore-keystorefile" v-model="newWalletFromKeystore.keystoreFile" @change="newWalletFromKeystoreFileChange($event.target.name, $event.target.files)"></b-form-file>
            </b-form-group>
            <b-form-group label="Password:" label-for="newwalletfromkeystore-keystorefilepassword" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="password" autocomplete="current-password" size="sm" id="newwalletfromkeystore-keystorefilepassword" v-model="newWalletFromKeystore.keystoreFilePassword" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromkeystore-load" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!newWalletFromKeystore.keystoreFile" id="newwalletfromkeystore-load" @click="newWalletFromKeystoreLoad()" variant="primary">Load</b-button>
            </b-form-group>
            <b-form-group label="Private Key:" label-for="newwalletfromkeystore-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfromkeystore-privatekey" v-model="newWalletFromKeystore.privateKey" style="max-width: 600px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Address:" label-for="newwalletfromkeystore-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="newwalletfromkeystore-address" :value="newWalletFromKeystore.address" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="newwalletfromkeystore-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newwalletfromkeystore-name" v-model.trim="newWalletFromKeystore.name" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="newwalletfromkeystore-password" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-0 pr-1">
                  <b-form-input type="password" size="sm" id="newwalletfromkeystore-password" v-model.trim="newWalletFromKeystore.password" placeholder="Password" style="max-width: 300px;"></b-form-input>
                </div>
                <div class="mt-0 pr-1">
                  <b-form-input type="password" size="sm" id="newwalletfromkeystore-confirmpassword" v-model.trim="newWalletFromKeystore.confirmPassword" placeholder="Confirm password" style="max-width: 300px;"></b-form-input>
                </div>
                <div class="mt-0 pr-1">
                  <b-button size="sm" :disabled="newWalletFromKeystore.adding || !newWalletFromKeystore.address || !newWalletFromKeystore.password || (newWalletFromKeystore.password != newWalletFromKeystore.confirmPassword)" id="newwalletfromkeystore-add" @click="newWalletFromKeystoreAdd()" variant="primary">{{ newWalletFromKeystore.adding ? "Adding " : "Add" }}<b-spinner v-if="newWalletFromKeystore.adding" small variant="light" label="Spinning"></b-spinner></b-button>
                </div>
              </div>
            </b-form-group>
          </b-modal>

          <!-- :MODALADDRESS -->
          <b-modal id="modal-address" hide-footer size="lg">
            <template #modal-title>
              {{ address.mode == 'add' ? 'New' : ''}} Address
            </template>
            <b-form-group label="Type:" label-for="address-type" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-select size="sm" :disabled="['walletfrommnemonic', 'walletfromprivatekey', 'walletfromkeystore'].includes(address.type)" id="address-type" v-model="address.type" :options="addressTypeOptions" style="max-width: 300px;"></b-form-select>
            </b-form-group>
            <b-form-group label="Address:" label-for="address-address" label-size="sm" label-cols-sm="3" label-align-sm="right" :state="!address.addressError" :invalid-feedback="address.addressError" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" :readonly="address.mode != 'add'" id="address-address" v-model.trim="address.address" @change="newAddressRecompute();" style="max-width: 400px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="address.mode == 'vieworupdate' && !address.privateKey && ['walletfrommnemonic', 'walletfromprivatekey', 'walletfromkeystore'].includes(address.type)" label="Private Key" label-for="address-privatekeypassword" label-size="sm" label-cols-sm="3" label-align-sm="right" :state="!address.passwordError" :invalid-feedback="address.passwordError" class="mx-0 my-1 p-0">
              <b-form-input type="password" size="sm" id="address-privatekeypassword" v-model.trim="address.password" @change="addressPrivateKeyPasswordUpdate();" placeholder="Enter password" debounce="600" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="address.mode == 'vieworupdate' && address.privateKey && ['walletfrommnemonic', 'walletfromprivatekey', 'walletfromkeystore'].includes(address.type)" label="Private Key" label-for="address-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" readonly id="address-privatekey" v-model.trim="address.privateKey" style="max-width: 600px;"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="address-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="address-name" v-model.trim="address.name" placeholder="Optional" style="max-width: 300px;"></b-form-input>
            </b-form-group>
            <b-form-group v-if="address.mode == 'add'" label="" label-for="address-add" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!address.address" id="address-add" @click="addressAdd()" variant="primary">Add</b-button>
            </b-form-group>
            <b-form-group v-if="address.mode == 'vieworupdate'" label="" label-for="address-update" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!address.address" id="address-update" @click="addressUpdate()" variant="primary">Update</b-button>
              <b-button size="sm" :disabled="!address.address" @click="addressDelete()" variant="warning">Delete</b-button>
            </b-form-group>
          </b-modal>

          <!-- :ADDRESSES -->
          <b-card v-if="settings.tabIndex == 0" class="m-0 p-0 border-0" body-class="m-1 p-0">
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-dropdown size="sm" variant="link" v-b-popover.hover.bottom="'New Address'">
                  <template #button-content>
                    <b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus>
                  </template>
                  <b-dropdown-item @click="showNewWalletFromMnemonic">New Wallet From Mnemonic</b-dropdown-item>
                  <b-dropdown-item @click="showNewWalletFromPrivateKey">New Wallet From Private Key</b-dropdown-item>
                  <b-dropdown-item @click="showNewWalletFromKeystore">New Wallet From Keystore</b-dropdown-item>
                  <b-dropdown-item @click="showAddressNew">New Address</b-dropdown-item>
                </b-dropdown>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pl-1">
                <font size="-2" v-b-popover.hover.bottom="'# addresses'">{{ commify0(addresses.length) }}</font>
              </div>
              <div class="mt-0 pl-1">
                <b-pagination size="sm" v-model="settings.addressesTable.currentPage" @input="saveSettings" :total-rows="filteredSortedAddresses.length" :per-page="settings.addressesTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.addressesTable.pageSize" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
              </div>
            </div>
            <b-table ref="addressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='addressesRowSelected' :fields="addressesFields" :items="pagedFilteredSortedAddresses" show-empty empty-html="Add new wallets" head-variant="light" class="mx-0 my-1">
              <template #cell(number)="data">
                <font size="-1">
                  {{ parseInt(data.index) + ((settings.addressesTable.currentPage - 1) * settings.addressesTable.pageSize) + 1 }}
                </font>
              </template>
              <template #cell(type)="data">
                <b-badge pill variant="transparent" class="px-0">{{ addressTypeOptions.filter(e => e.value == data.item.type)[0].text }}</b-badge>
              </template>
            </b-table>
          </b-card>

          <!-- :ETH -->
          <b-card v-if="settings.tabIndex == 1" class="m-0 p-0 border-0" body-class="m-1 p-0">
            <!-- :SIGNETHTX -->
            <b-card sub-title="Sign ETH Transaction Offline" bg-variant="light" class="p-0 m-1" style="max-width: 900px;">
              <b-form-group label-cols-lg="2" label="Input" label-size="md" label-class="font-weight-bold pt-0" class="mb-0 mt-3">
                <b-form-group label="Action:" label-for="signethtx-action" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-select size="sm" id="signethtx-action" v-model="settings.signEthTx.action" :options="actionOptions" @change="saveSettings();" style="max-width: 300px;"></b-form-select>
                </b-form-group>
                <b-form-group label="From:" label-for="signethtx-from" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-select size="sm" id="signethtx-from" v-model="settings.signEthTx.from" :options="walletsOptions" @change="saveSettings();" v-b-popover.hover.bottom="'Select Wallet'"></b-form-select>
                </b-form-group>
                <b-form-group label="To:" label-for="signethtx-to" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-select size="sm" id="signethtx-to" v-model="settings.signEthTx.to" :options="addressesOptions" @change="saveSettings();" v-b-popover.hover.bottom="'Select Address'"></b-form-select>
                </b-form-group>
                <b-form-group label="Amount:" label-for="signethtx-amount" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                  <div class="d-flex flex-wrap m-0 p-0">
                    <div class="mt-0 pr-1">
                      <b-form-input type="text" size="sm" id="signethtx-amount" v-model.trim="settings.signEthTx.amount" @change="saveSettings();"></b-form-input>
                    </div>
                    <div class="mt-0 pr-1">
                      <b-form-select size="sm" v-model="settings.signEthTx.amountUnit" :options="unitOptions" @change="saveSettings();"></b-form-select>
                    </div>
                  </div>
                </b-form-group>
              </b-form-group>
              <b-form-group label-cols-lg="2" label="Network Parameters" label-size="md" label-class="font-weight-bold pt-0" class="mb-0 mt-2">
                <b-form-group label="Chain:" label-for="signethtx-chain" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" size="sm" id="signethtx-chain" v-model.trim="settings.signEthTx.chainId" @change="saveSettings();" style="max-width: 150px;"></b-form-input>
                </b-form-group>
                <b-form-group label="Nonce:" label-for="signethtx-nonce" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" size="sm" id="signethtx-nonce" v-model.trim="settings.signEthTx.nonce" @change="saveSettings();" style="max-width: 150px;"></b-form-input>
                </b-form-group>
                <b-form-group label="Gas Limit:" label-for="simulateethtx-gaslimit" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Set this to 10% above the Estimated Gas from the Offline page" class="mx-0 my-1 p-0">
                  <b-form-input type="text" size="sm" id="simulateethtx-gaslimit" v-model.trim="settings.signEthTx.gasLimit" @change="saveSettings();" style="max-width: 150px;"></b-form-input>
                </b-form-group>
              </b-form-group>
              <!-- <b-form-group label="Data:" label-for="signethtx-data" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-textarea size="sm" id="signethtx-data" v-model="signEthTx.data" rows="3" placeholder="Optional, 0x{hex}" style="max-width: 800px;"></b-form-textarea>
              </b-form-group> -->
              <!-- <b-form-group label="Nonce:" label-for="signethtx-nonce" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="signethtx-nonce" v-model.trim="signEthTx.nonce" placeholder="Latest unused" style="max-width: 150px;"></b-form-input>
              </b-form-group> -->
            </b-card>
            <!-- <b-form-group label="Test:" label-for="wallet-testit" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="wallet-testit" @click="testIt()" variant="warning">Test</b-button>
            </b-form-group> -->
          </b-card>

          <!-- :ERC20 -->
          <b-card v-if="settings.tabIndex == 2" class="m-0 p-0 border-0" body-class="m-1 p-0">
            TODO: ERC-20 Functions - approve, transfer, transferFrom
          </b-card>

          <!-- :ERC721 -->
          <b-card v-if="settings.tabIndex == 3" class="m-0 p-0 border-0" body-class="m-1 p-0">
            TODO: ERC-721 Functions - *approv*, *transfer*
          </b-card>

          <!-- :MESSAGES -->
          <b-card v-if="settings.tabIndex == 4" class="m-0 p-0 border-0" body-class="m-1 p-0">
            <!-- :SIGNMESSAGE -->
            <b-card sub-title="Sign Message" bg-variant="light" class="m-1 p-0" style="max-width: 1000px;">
              <b-form-group label="Wallet:" label-for="signmessage-wallet" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                <b-form-select size="sm" id="signmessage-wallet" v-model="signMessage.wallet" :options="addressesOptions" v-b-popover.hover.bottom="'Select Wallet'"></b-form-select>
              </b-form-group>
              <b-form-group label="Message:" label-for="signmessage-message" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" id="signmessage-message" v-model.trim="signMessage.message" rows="3" placeholder="Type/paste your message here, then click [Sign]" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
              <b-form-group label="" label-for="signmessage-sign" label-size="sm" label-cols-sm="2" label-align-sm="right" :state="!signMessage.passwordError" :invalid-feedback="signMessage.passwordError" class="mx-0 my-1 p-0">

                <b-input-group style="max-width: 300px;">
                  <b-form-input type="password" size="sm" v-model.trim="signMessage.password" placeholder="Wallet password"></b-form-input>
                  <b-input-group-append>
                    <b-button size="sm" :disabled="!signMessage.wallet || !signMessage.message || !signMessage.password" id="signmessage-sign" @click="signMessageSign()" variant="primary">Sign</b-button>
                  </b-input-group-append>
                </b-input-group>
              </b-form-group>
              <b-form-group label="Signature:" label-for="signmessage-signature" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" readonly id="signmessage-signature" v-model.trim="signMessage.signature" rows="3" placeholder="Click [Sign]" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
            </b-card>

            <!-- :CHECKMESSAGE -->
            <b-card sub-title="Check Message" bg-variant="light" class="m-1 mt-3 p-0" style="max-width: 1000px;">
              <b-form-group label="Message:" label-for="checkmessage-message" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" id="checkmessage-message" v-model="checkMessage.message" rows="3" placeholder="Type/paste your message here, then click [Sign]" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
              <b-form-group label="Signature:" label-for="checkmessage-signature" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-2 p-0">
                <b-form-textarea size="sm" id="checkmessage-signature" v-model="checkMessage.signature" rows="3" placeholder="Paste your signature here" style="max-width: 800px;"></b-form-textarea>
              </b-form-group>
              <b-form-group label="Recovered Address:" label-for="checkmessage-recoveredaddress" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-3 p-0">
                <b-form-input type="text" size="sm" readonly id="checkmessage-recoveredaddress" :value="checkMessageRecoveredAddress" style="max-width: 500px;"></b-form-input>
              </b-form-group>
            </b-card>
          </b-card>
        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="false && connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>Offline:TopSecrets</i> &copy; Bok Consulting Pty Ltd 2024
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          newWalletFromMnemonic: {
            phrase: null,
            randomBytesLength: 16, // 12 words
            phraseError: null,
            passphrase: null,
            confirmPassphrase: null,
            derivationPath: "m/44'/60'/0'/0/{index}",
            page: 0,
            pageSize: 10,
            selectedItem: null,
            name: null,
            // path: "m/44'/60'/0'/0/0", // null,
            // locale: null,
            password: null,
            confirmPassword: null,
            adding: null,
          },

          newWalletFromPrivateKey: {
            privateKey: null,
            privateKeyError: null,
            address: null,
            name: null,
            password: null,
            confirmPassword: null,
            adding: null,
          },

          newWalletFromKeystore: {
            keystoreFile: null,
            keystoreFilePassword: null,
            keystoreFileContent: null,
            privateKey: null,
            address: null,
            name: null,
            password: null,
            confirmPassword: null,
            adding: null,
          },

          address: {
            mode: 'vieworupdate', // TODO: 'add' or 'vieworupdate'
            type: null,
            address: null,
            addressError: null,
            name: null,
            keystore: null,
            password: null,
            passwordError: null,
            privateKey: null,
          },

          signMessage: {
            wallet: null,
            message: null,
            signature: null,
            password: null,
            passwordError: null,
          },

          checkMessage: {
            message: null,
            signature: null,
          },

          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,
          forceRefresh: 0,

          settings: {
            tabIndex: 0,

            signEthTx: {
              action: null,
              from: null,
              to: null,
              amount: null,
              amountUnit: "ether",
              data: null,
              chainId: null,
              nonce: null,
              gasLimit: null,
              lastBaseFeePerGas: null,
              maxFeePerGas: null,
              maxPriorityFeePerGas: null,
              gasPrice: null,
              lastBaseFeePerGasUnit: "gwei",
              maxFeePerGasUnit: "gwei",
              maxPriorityFeePerGasUnit: "gwei",
              gasPriceUnit: "gwei",
              signature: null,
              error: null,
            },

            addressesTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'addressasc',
            },
            version: 12,
          },
          addresses: {},

          tabs: [
            { name: 'mnemonic', text: 'Mnemonic Seed Phrase' },
            { name: 'privatekey', text: 'Private Key' },
          ],

          addressTypeOptions: [
            { value: 'walletfrommnemonic', text: 'Wallet From Mnemonic', disabled: true },
            { value: 'walletfromprivatekey', text: 'Wallet From Private Key', disabled: true },
            { value: 'walletfromkeystore', text: 'Wallet From Keystore', disabled: true },
            { value: 'address', text: 'Address' },
            { value: 'erc20', text: 'ERC-20 Token Contract' },
            { value: 'erc721', text: 'ERC-721 Token Contract' },
            { value: 'contract', text: 'Contract' },
          ],

          randomBytesLengthMnemonicWordsOptions: [
            { value: 16, text: '12 Words' },
            { value: 20, text: '15 Words' },
            { value: 24, text: '18 Words' },
            { value: 28, text: '21 Words' },
            { value: 32, text: '24 Words' },
          ],

          actionOptions: [
            { value: null, text: '(Select)' },
            { value: 'simpleethtransfer', text: 'Simple ETH Transfer' }, // TODO: Type 2
            { value: 'sweepwallet', text: 'Sweep ETH To New Wallet', disabled: true }, // TODO: Type 1 with amount = balance - gasLimit * gasPrice
            { value: 'deploycontract', text: 'Deploy Contract', disabled: true }, // TODO: `to` null; data with code
            { value: 'writemessage', text: 'Write Message', disabled: true }, // TODO: `to` to own account, or destination; data with message
          ],

          unitOptions: [
            { value: "ether", text: 'Ether' },
            { value: "gwei", text: 'Gwei' },
            { value: "wei", text: 'Wei' },
          ],

          // MM HW Paths
          // Ledger Live
          // Legacy (MEW/MyCrypto)
          // BIP44 Standard (e.g. MetaMask, Trezor)
          derivationPathOptions: [
            { value: "m/44'/60'/0'/0/{index}", text: "BIP-44 m/44'/60'/0'/0/{index}" },
            // { value: "m/44'/60'/0'/0/{index}", text: "Legacy (MEW/MyCrypto) m/44'/60'/0'/0/{index}" }, // TODO: Check difference in MM settings with Ledger
            { value: "m/44'/60'/0'/{index}/0", text: "Test-1 m/44'/60'/0'/{index}/0" },
            { value: "m/44'/60'/0'/0/{index}/0", text: "Test-2 m/44'/60'/0'/0/{index}/0" },
          ],

          indexPageSizeOptions: [
            { value: 1, text: '1' },
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
          ],

          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],

          newWalletFromMnemonicAddressesFields: [
            { key: 'index', label: '#', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'path', label: 'Path', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 60%;', thClass: 'text-left', tdClass: 'text-left' },
            // { key: 'privateKey', label: 'Private Key', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
          ],

          addressesFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-truncate' },
          ],

        },

        // --- COMPUTED ---
        computed: {

          walletsOptions() {
            const results = [];
            results.push({ value: null, text: "(Select Wallet)" });
            for (const [address, data] of Object.entries(this.addresses)) {
              if (data.type.substring(0, 6) == "wallet") {
                results.push({ value: address, text: address + (data.name ? (" " + data.name) : "") });
              }
            }
            return results;
          },

          addressesOptions() {
            const results = [];
            results.push({ value: null, text: "(Select Address)" });
            for (const [address, data] of Object.entries(this.addresses)) {
              results.push({ value: address, text: address + (data.name ? (" " + data.name) : "") });
            }
            return results;
          },

          checkMessageRecoveredAddress() {
            let result = null;
            if (this.checkMessage.message && this.checkMessage.signature) {
              try {
                console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress - message: " + this.checkMessage.message);
                let pubKey = ethers.utils.recoverPublicKey(ethers.utils.arrayify(ethers.utils.hashMessage(this.checkMessage.message)), this.checkMessage.signature);
                result = ethers.utils.computeAddress(pubKey);
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " checkMessageRecoveredAddress ERROR: " + e.message);
              }
            }
            return result;
          },

          newWalletFromMnemonicAddresses() {
            const results = [];
            if (this.newWalletFromMnemonic.phrase && (this.newWalletFromMnemonic.passphrase == this.newWalletFromMnemonic.confirmPassphrase)) {
              try {
                const node = ethers.utils.HDNode.fromMnemonic(this.newWalletFromMnemonic.phrase, this.newWalletFromMnemonic.passphrase);
                for (let i = 0; i < this.newWalletFromMnemonic.pageSize; i++) {
                  const index = parseInt(i) + (this.newWalletFromMnemonic.page * this.newWalletFromMnemonic.pageSize);
                  let path = this.newWalletFromMnemonic.derivationPath.replace(/{index}/, index);
                  console.log("index: " + index + " => " + path);
                  const w = node.derivePath(path);
                  results.push({
                    index,
                    path,
                    privateKey: w.privateKey,
                    address: w.address,
                    // publicKey: w.publicKey,
                    // compressedPublicKey: ethers.utils.computePublicKey(w.publicKey, true),
                  });
                }
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAddresses ERROR: " + e.message);
              }
            }
            return results;
          },

          filteredAddresses() {
            // console.log(moment().format("HH:mm:ss") + " filteredAddresses: " + JSON.stringify(this.addresses));
            // let results = this.forceRefresh % 2 == 0 ? [] : [];
            const results = [];
            for (const [address, data] of Object.entries(this.addresses)) {
              results.push({
                address,
                type: data.type,
                keystore: data.keystore,
                name: data.name,
              });
            }
            return results;
          },
          filteredSortedAddresses() {
            let results = this.filteredAddresses;
          //   if (this.settings.accountsTable.sortOption == 'typenameasc') {
          //     results.sort((a, b) => {
          //       const typeA = a.customType || a.type;
          //       const typeB = b.customType || b.type;
          //       const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
          //       const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
          //       if (sortIndexA == sortIndexB) {
          //         const namea = a.customName || a.name;
          //         const nameb = b.customName || b.name;
          //         return ('' + namea).localeCompare(nameb);
          //       } else {
          //         return sortIndexA - sortIndexB;
          //       }
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'typenamedsc') {
          //     results.sort((a, b) => {
          //       const typeA = a.customType || a.type;
          //       const typeB = b.customType || b.type;
          //       const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
          //       const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
          //       if (sortIndexA == sortIndexB) {
          //         const namea = a.customName || a.name;
          //         const nameb = b.customName || b.name;
          //         return ('' + nameb).localeCompare(namea);
          //       } else {
          //         return sortIndexB - sortIndexA;
          //       }
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'nameasc') {
          //     results.sort((a, b) => {
          //       return ('' + a.name).localeCompare(b.name);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'namedsc') {
          //     results.sort((a, b) => {
          //       return ('' + b.name).localeCompare(a.name);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'addressasc') {
          //     results.sort((a, b) => {
          //       return ('' + a.address).localeCompare(b.address);
          //     });
          //   } else if (this.settings.accountsTable.sortOption == 'addressdsc') {
          //     results.sort((a, b) => {
          //       return ('' + b.address).localeCompare(a.address);
          //     });
          //   }
            return results;
          },
          pagedFilteredSortedAddresses() {
            console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedAddresses - results[0..1]: " + JSON.stringify(this.filteredSortedAddresses.slice(0, 2), null, 2));
            return this.filteredSortedAddresses.slice((this.settings.addressesTable.currentPage - 1) * this.settings.addressesTable.pageSize, this.settings.addressesTable.currentPage * this.settings.addressesTable.pageSize);
          },

          accountsToSearch() {
            return this.settings.searchAttachedAccount ? [ this.coinbase ] : (this.settings.searchAccounts && this.settings.searchAccounts.split(/[, \t\n]+/).filter(name => name.match(/0x[0-9a-fA-F]{40}/)) || []);
          },
        },

        // --- METHODS ---
        methods: {

          updateURL(where) {
            console.log(moment().format("HH:mm:ss") + " TODO updateURL: " + where);
          },

          addressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " addressesRowSelected: " + JSON.stringify(item));
            if (item && item.length > 0) {
              this.address.mode = 'vieworupdate';
              this.address.type = item[0].type;
              this.address.address = item[0].address;
              this.address.addressError = null;
              this.address.name = item[0].name;
              this.address.keystore = item[0].keystore;
              this.address.password = null;
              this.address.privateKey = null;
              console.log(moment().format("HH:mm:ss") + " addressesRowSelected - this.address: " + JSON.stringify(this.address));
              this.$refs.addressesTable.clearSelected();
            }
            this.$bvModal.show('modal-address');
          },

          showNewWalletFromMnemonic() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromMnemonic");
            this.$bvModal.show('modal-newwalletfrommnemonic');
          },
          showNewWalletFromPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromPrivateKey");
            this.$bvModal.show('modal-newwalletfromprivatekey');
          },
          showNewWalletFromKeystore() {
            console.log(moment().format("HH:mm:ss") + " showNewWalletFromKeystore");
            this.$bvModal.show('modal-newwalletfromkeystore');
          },
          showAddressNew() {
            console.log(moment().format("HH:mm:ss") + " showAddressNew");
            this.address.mode = 'add';
            this.address.type = 'address';
            this.address.address = null;
            this.address.addressError = null;
            this.address.name = null;
            this.address.keystore = null;
            this.address.password = null;
            this.address.passwordError = null;
            this.address.privateKey = null;
            this.$bvModal.show('modal-address');
          },

          newWalletFromMnemonicGenerateRandom() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicGenerateRandom");
            try {
              const randomBytes = ethers.utils.randomBytes(this.newWalletFromMnemonic.randomBytesLength);
              this.newWalletFromMnemonic.phrase = ethers.utils.entropyToMnemonic(randomBytes);
              this.newWalletFromMnemonic.phraseError = null;
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicGenerateRandom ERROR: " + e.message);
            }
          },

          newWalletFromMnemonicRecompute() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicRecompute");
            if (this.newWalletFromMnemonic.phrase) {
              try {
                const node = ethers.utils.HDNode.fromMnemonic(this.newWalletFromMnemonic.phrase);
                this.newWalletFromMnemonic.phraseError = null;
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicRecompute ERROR: " + e.message);
                this.newWalletFromMnemonic.phraseError = e.message;
              }
            } else {
              this.newWalletFromMnemonic.phraseError = null;
            }
          },

          newWalletFromMnemonicAddressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAddressesRowSelected: " + JSON.stringify(item));
            if (item && item.length > 0) {
              this.newWalletFromMnemonic.selectedItem = item[0];
              this.$bvModal.show('modal-newwalletfrommnemonic-add');
            } else {
              this.newWalletFromMnemonic.selectedItem = null;
            }
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAddressesRowSelected - this.newWalletFromMnemonic: " + JSON.stringify(this.newWalletFromMnemonic, null, 2));
          },

          async newWalletFromMnemonicAdd() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAdd - this.newWalletFromMnemonic: " + JSON.stringify(this.newWalletFromMnemonic, null, 2));
            this.newWalletFromMnemonic.adding = true;
            const wallet = new ethers.Wallet(this.newWalletFromMnemonic.selectedItem.privateKey);
            const encryptedText = await wallet.encrypt(this.newWalletFromMnemonic.password);
            const keystore = JSON.parse(encryptedText);
            keystore.filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.newWalletFromMnemonic.selectedItem.address.slice(2).toLowerCase();
            Vue.set(this.addresses, this.newWalletFromMnemonic.selectedItem.address, {
              type: "walletfrommnemonic",
              name: this.newWalletFromMnemonic.name,
              keystore,
            });
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " newWalletFromMnemonicAdd - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-newwalletfrommnemonic-add');
            this.newWalletFromMnemonic.adding = null;
          },

          newWalletFromPrivateKeyGenerateRandom() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom");
            try {
              const randomBytes = ethers.utils.randomBytes(16);
              const phrase = ethers.utils.entropyToMnemonic(randomBytes);
              const node = ethers.utils.HDNode.fromMnemonic(phrase);
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom - node: " + JSON.stringify(node, null, 2));
              const defaultPath = "m/44'/60'/0'/0/0";
              const wallet = node.derivePath(defaultPath);
              this.newWalletFromPrivateKey.privateKey = wallet.privateKey;
              this.newWalletFromPrivateKey.privateKeyError = null;
              this.newWalletFromPrivateKey.address = wallet.address;
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom - this.newWalletFromPrivateKey: " + JSON.stringify(this.newWalletFromPrivateKey, null, 2));
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyGenerateRandom ERROR: " + e.message);
            }
          },

          newWalletFromPrivateKeyRecompute() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyRecompute: " + JSON.stringify(this.newWalletFromPrivateKey));
            if (this.newWalletFromPrivateKey.privateKey) {
              try {
                const wallet = new ethers.Wallet(this.newWalletFromPrivateKey.privateKey);
                this.newWalletFromPrivateKey.privateKeyError = null;
                this.newWalletFromPrivateKey.address = wallet.address;
                console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyRecompute - AFTER: " + JSON.stringify(this.newWalletFromPrivateKey));
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyRecompute - privatekey ERROR: " + e.message);
                this.newWalletFromPrivateKey.privateKeyError = e.message;
                this.newWalletFromPrivateKey.address = null;
              }
            } else {
              this.newWalletFromPrivateKey.privateKeyError = null;
              this.newWalletFromPrivateKey.address = null;
            }
          },

          async newWalletFromPrivateKeyAdd() {
            this.newWalletFromPrivateKey.adding = true;
            const wallet = new ethers.Wallet(this.newWalletFromPrivateKey.privateKey);
            const encryptedText = await wallet.encrypt(this.newWalletFromPrivateKey.password);
            const keystore = JSON.parse(encryptedText);
            keystore.filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.newWalletFromPrivateKey.address.slice(2).toLowerCase();
            Vue.set(this.addresses, this.newWalletFromPrivateKey.address, {
              type: "walletfromprivatekey",
              name: this.newWalletFromPrivateKey.name,
              keystore,
            });
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " newWalletFromPrivateKeyAdd - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-newwalletfromprivatekey');
            this.newWalletFromPrivateKey.adding = null;
          },

          async newWalletFromKeystoreFileChange(fileName, fileList) {
            console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreFileChange: " + JSON.stringify(fileName));
            const reader = new FileReader();
            this.newWalletFromKeystore.keystoreFileContent = {};
            const t = this;
            reader.onload = function (event) {
              const data = event.target.result;
              t.newWalletFromKeystore.keystoreFileContent = data;
              console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreFileChange - keystoreFileContent: " + t.newWalletFromKeystore.keystoreFileContent);
            };
            await reader.readAsText(fileList[0]);
          },

          async newWalletFromKeystoreLoad() {
            console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreLoad - this.newWalletFromKeystore.keystoreFileContent: " + this.newWalletFromKeystore.keystoreFileContent);
            console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreLoad - this.newWalletFromKeystore.keystoreFilePassword: " + this.newWalletFromKeystore.keystoreFilePassword);
            try {
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(this.newWalletFromKeystore.keystoreFileContent, this.newWalletFromKeystore.keystoreFilePassword);
              this.newWalletFromKeystore.privateKey = wallet.privateKey;
              this.newWalletFromKeystore.address = wallet.address;
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreLoad - keystorefile ERROR: " + e.message);
            }
          },

          async newWalletFromKeystoreAdd() {
            this.newWalletFromKeystore.adding = true;
            const wallet = new ethers.Wallet(this.newWalletFromKeystore.privateKey);
            const encryptedText = await wallet.encrypt(this.newWalletFromKeystore.password);
            const keystore = JSON.parse(encryptedText);
            keystore.filename = "UTC--" + moment.utc().format("YYYY-MM-DDTHH-mm-ss") + ".0Z--" + this.newWalletFromKeystore.address.slice(2).toLowerCase();
            Vue.set(this.addresses, this.newWalletFromKeystore.address, {
              type: "walletfromkeystore",
              name: this.newWalletFromKeystore.name,
              keystore,
            });
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " newWalletFromKeystoreAdd - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-newwalletfromkeystore');
            this.newWalletFromKeystore.adding = null;
          },

          newAddressRecompute() {
            console.log(moment().format("HH:mm:ss") + " newAddressRecompute: " + JSON.stringify(this.address));
            if (this.address.address) {
              try {
                const addr = ethers.utils.getAddress(this.address.address);
                this.address.addressError = null;
                console.log(moment().format("HH:mm:ss") + " newAddressRecompute - AFTER: " + JSON.stringify(this.address));
              } catch (e) {
                console.log(moment().format("HH:mm:ss") + " newAddressRecompute - ERROR: " + e.message);
                this.address.addressError = e.message;
              }
            } else {
              this.address.addressError = null;
            }
          },

          async addressAdd() {
            console.log(moment().format("HH:mm:ss") + " addressAdd - this.address: " + JSON.stringify(this.address, null, 2));
            Vue.set(this.addresses, this.address.address, {
              type: this.address.type,
              name: this.address.name,
            });
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " addressAdd - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-address');
          },

          async addressPrivateKeyPasswordUpdate() {
            try {
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(JSON.stringify(this.address.keystore), this.address.password);
              this.address.privateKey = wallet.privateKey;
              this.address.passwordError = null;
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " addressPrivateKeyPasswordUpdate - keystorefile ERROR: " + e.message);
              this.address.passwordError = e.message;
              this.address.privateKey = null;
            }
            console.log(moment().format("HH:mm:ss") + " addressPrivateKeyPasswordUpdate AFTER - this.address: " + JSON.stringify(this.address, null, 2));
          },

          async addressUpdate() {
            console.log(moment().format("HH:mm:ss") + " addressUpdate - this.address: " + JSON.stringify(this.address, null, 2));
            Vue.set(this.addresses[this.address.address], 'type', this.address.type);
            Vue.set(this.addresses[this.address.address], 'name', this.address.name);
            localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " addressUpdate - this.addresses: " + JSON.stringify(this.addresses, null, 2));
            this.$bvModal.hide('modal-address');
          },

          async addressDelete() {
            console.log(moment().format("HH:mm:ss") + " addressDelete - this.address: " + JSON.stringify(this.address, null, 2));
            this.$bvModal.msgBoxConfirm("Delete " + this.address.address + '?')
              .then(confirmed => {
                if (confirmed) {
                  Vue.delete(this.addresses, this.address.address);
                  localStorage.topSecretsOfflineAddresses = JSON.stringify(this.addresses);
                  console.log(moment().format("HH:mm:ss") + " addressDelete - this.addresses: " + JSON.stringify(this.addresses, null, 2));
                  this.$bvModal.hide('modal-address');
                }
              })
              .catch(err => {
              });
          },

          async signMessageSign() {
            console.log(moment().format("HH:mm:ss") + " signMessageSign - this.signMessage: " + JSON.stringify(this.signMessage, null, 2));
            const walletInfo = this.addresses[this.signMessage.wallet];
            // console.log(moment().format("HH:mm:ss") + " signMessageSign - walletInfo: " + JSON.stringify(walletInfo, null, 2));
            try {
              const wallet = await ethers.Wallet.fromEncryptedJsonSync(JSON.stringify(walletInfo.keystore), this.signMessage.password);
              // console.log(moment().format("HH:mm:ss") + " signMessageSign - wallet: " + JSON.stringify(wallet, null, 2));
              const signature = await wallet.signMessage(this.signMessage.message);
              // console.log(moment().format("HH:mm:ss") + " signMessageSign - signature: " + JSON.stringify(signature, null, 2));
              Vue.set(this.signMessage, 'signature', signature);
              this.signMessage.passwordError = null;
            } catch (e) {
              console.log(moment().format("HH:mm:ss") + " signMessageSign - keystorefile ERROR: " + e.message);
              Vue.set(this.signMessage, 'signature', null);
              this.signMessage.passwordError = e.message;
            }
          },

          async testIt() {
            console.log(moment().format("HH:mm:ss") + " testIt");
            const privateKey = "{myprivatekey}";
            const wallet = new ethers.Wallet(privateKey);
            const WEENUSADDRESS = "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9";
            const interface = new ethers.utils.Interface(ERC20ABI);
            const contractWithoutProvider = new ethers.Contract(WEENUSADDRESS, interface, wallet);
            const unsignedTx = await contractWithoutProvider.populateTransaction.transfer(wallet.address, 1);
            console.log("unsignedTx: " + JSON.stringify(unsignedTx, null, 2));
            console.log("address: " + wallet.address);
            const tx = {
              from: wallet.address,
              to: "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9",
              gasLimit: 50000,
              // gasPrice: 1000000,
              type: 2,
              maxFeePerGas: 1234000,
              maxPriorityFeePerGas: 1234000,
              value: 0,
              data: unsignedTx.data,
              nonce: 36,
              chainId: 11155111,
            };
            console.log("tx: " + JSON.stringify(tx));
            const signedTx = await wallet.signTransaction(tx);
            console.log("signedTx: " + signedTx);
            const decoded = ethers.utils.parseTransaction(signedTx);
            console.log("decoded: " + JSON.stringify(decoded, null, 2));
          },

          async testItOld() {
            console.log(moment().format("HH:mm:ss") + " testIt");
            const privateKey = "{myprivatekey}";
            const wallet = new ethers.Wallet(privateKey);
            console.log("address: " + wallet.address);
            const tx = {
              from: wallet.address,
              to: "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9",
              gasLimit: 50000,
              // gasPrice: 1000000,
              type: 2,
              maxFeePerGas: 1234000,
              maxPriorityFeePerGas: 1234000,
              value: 0,
              data: "",
              nonce: 35,
              chainId: 11155111,
            };
            console.log("tx: " + JSON.stringify(tx));
            // const populatedTx = await wallet.populateTransaction(tx);
            // console.log("populatedTx: " + populatedTx);
            const sig = await wallet.signTransaction(tx);
            console.log("sig: " + sig);
          },

          saveSettings() {
            localStorage.topSecretsOfflineSettings = JSON.stringify(this.settings);
          },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          // formatETH(e, precision = 9) {
          //   try {
          //     if (precision == 0) {
          //       return e ? ethers.utils.formatEther(e) : null;
          //     } else {
          //       return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
          //     }
          //   } catch (err) {
          //   }
          //   return e.toFixed(precision);
          // },
          // formatDecimals(e, decimals = 18) {
          //   return e ? ethers.utils.formatUnits(e, decimals) : null;
          // },
          // formatTimestamp(ts) {
          //   if (ts != null) {
          //     if (this.settings.reportingDateTime == 1) {
          //       return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
          //     } else {
          //       return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
          //     }
          //   }
          //   return null;
          // },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
        },

        // --- MOUNTED ---
        mounted() {
          if ('topSecretsOfflineAddresses' in localStorage) {
            this.addresses = JSON.parse(localStorage.topSecretsOfflineAddresses);
          }
          if ('topSecretsOfflineSettings' in localStorage) {
            const tempSettings = JSON.parse(localStorage.topSecretsOfflineSettings);
            if ('version' in tempSettings && tempSettings.version == this.settings.version) {
              this.settings = tempSettings;
              // if (this.settings.addressesTable.currentPage > 1) {
              //   this.settings.addressesTable.currentPage = 1;
              // }
            }
          }
        },
      })
    </script>
  </body>
</html>
